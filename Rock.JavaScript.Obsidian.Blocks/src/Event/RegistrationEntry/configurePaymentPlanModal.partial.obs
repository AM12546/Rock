<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->

<template>
    <Modal v-model="internalIsShown"
           :isSaveButtonDisabled="!paymentDeadlineDate"
           :saveText="paymentDeadlineDate ? 'Select' : ''"
           title="Configure Payment Plan"
           @save="onConfigurePaymentPlan">
        <template v-if="paymentPlanConfiguration && paymentDeadlineDate.isLaterThan(RockDateTime.now())">
            <StaticFormControl :modelValue="`The total amount of ${props.balanceDue} is payable by ${paymentDeadlineDate.toASPString('MMMM dd, yyyy')}.`" />

            <div class="row">
                <div class="col">
                    <DropDownList :modelValue="paymentPlanFrequency.transactionFrequency.definedValueGuid"
                                  @update:modelValue="onUpdatePaymentFrequencyGuid"
                                  :items="paymentFrequencyItems"
                                  label="Select Your Desired Payment Frequency"
                                  rules="required" />
                </div>
            </div>

            <div class="row">
                <div class="col">
                    <DatePicker :modelValue="startDateIsoString"
                                @update:modelValue="onUpdateStartDateIsoString"
                                label="Start Date"
                                :disallowPastDateSelection="true" />
                </div>
            </div>

            <div :class="['row', !isPaymentPlanFrequencySelected ? 'invisible' : '']">
                <div class="col-sm-6">
                    <CurrencyBox :modelValue="amountToPayTodayPlusAdjustmentCurrency.number"
                                 @update:modelValue="onUpdateAmountToPayToday"
                                 label="Amount To Pay Today"
                                 :rules="['required', validateAmountToPayTodayRule, validateAmountToPayTodayLessThanRemaining]"
                                 @blur="onBlurAmountToPayToday">

                        <template #append>
                            <small>A minimum of {{ paymentPlanConfiguration?.minAmountToPayToday }} is due today.</small>
                        </template>
                    </CurrencyBox>
                </div>

                <div class="col-sm-6" v-if="numberOfPaymentsItems.length">
                    <DropDownList :modelValue="numberOfPayments + ''"
                                  @update:modelValue="onUpdateNumberOfPaymentsStringOrEmpty"
                                  :items="numberOfPaymentsItems"
                                  label="Number of Payments"
                                  rules="required"
                                  :showBlankItem="false" />
                </div>
            </div>

            <div :class="['row', !isPaymentPlanFrequencySelected || paymentPlanConfiguration.amountPerPayment.isInvalid ? 'invisible' : '']">
                <div class="col">
                    <RockLabel label="Plan Summary">Plan Summary</RockLabel>
                </div>
            </div>

            <div :class="['row', !isPaymentPlanFrequencySelected || paymentPlanConfiguration.amountPerPayment.isInvalid ? 'invisible' : '']">
                <div class="col-sm-6">
                    <div>Amount Due Today</div>
                    <div>
                        {{ amountToPayTodayPlusAdjustmentCurrency }}
                        <template v-if="amountToPayTodaySuffix"><small>&nbsp;({{ amountToPayTodaySuffix }})</small></template>
                    </div>
                </div>

                <div class="col-sm-6" v-if="numberOfPaymentsItems.length && paymentPlanConfiguration.amountPerPayment.isGreaterThan(0)">
                    <div>{{ paymentPlanFrequency.listItemBag.text }} Payment Amount</div>
                    <div>{{ paymentAmountMessage }}</div>
                </div>
            </div>
        </template>
        <template v-else>
            A payment deadline date is required to create a payment plan.
        </template>
    </Modal>
</template>

<script setup lang="ts">
    import { PropType, computed, ref, watch, nextTick } from "vue";
    import CurrencyBox from "@Obsidian/Controls/currencyBox.obs";
    import DropDownList from "@Obsidian/Controls/dropDownList.obs";
    import DatePicker from "@Obsidian/Controls/datePicker.obs";
    import Modal from "@Obsidian/Controls/modal.obs";
    import RockLabel from "@Obsidian/Controls/rockLabel.obs";
    import StaticFormControl from "@Obsidian/Controls/staticFormControl.obs";
    import { ListItemBag } from "@Obsidian/ViewModels/Utility/listItemBag";
    import { PaymentPlanConfiguration, PaymentPlanConfigurationOptions, PaymentPlanFrequency, getPaymentPlanConfiguration, noopPaymentPlanFrequency } from "./utils.partial";
    import { RockDateTime } from "@Obsidian/Utility/rockDateTime";
    import { Guid } from "@Obsidian/Types";
    import { ValidationResult } from "@Obsidian/ValidationRules";
    import { useVModelPassthrough } from "@Obsidian/Utility/component";
    import { createCurrency, createZeroCurrency, Currency, CurrencyOptions } from "./currency.partial";
    import { toNumber } from "@Obsidian/Utility/numberUtils";
    import { areEqual } from "@Obsidian/Utility/guid";

    const props = defineProps({
        modelValue: {
            type: Boolean as PropType<boolean>,
            default: false,
        },

        /**
         * The allowed payment plan frequencies.
         */
        paymentPlanFrequencies: {
            type: Object as PropType<PaymentPlanFrequency[]>,
            required: true,
        },

        paymentDeadlineDate: {
            type: Object as PropType<RockDateTime>,
            required: true,
        },

        currencyOptions: {
            type: Object as PropType<CurrencyOptions>,
            required: true,
        },

        /**
         * The outstanding balance due (the amount that is still owed).
         */
        balanceDue: {
            type: Object as PropType<Currency>,
            required: true,
        },

        /** The payment plan configuration (reactive). */
        paymentPlanConfiguration: {
            type: Object as PropType<PaymentPlanConfiguration | undefined>,
            required: true,
        }
    });

    const emit = defineEmits<{
        (e: "update:modelValue", value: boolean): void;
        (e: "update:paymentPlanConfiguration", value: PaymentPlanConfiguration): void;
        (e: "configure", value: PaymentPlanConfiguration): void;
    }>();

    const zeroCurrency = createZeroCurrency(props.currencyOptions);

    //#region Values

    // Initialize refs with empty values,
    // then call a separate initialize function for code clarity.
    const paymentFrequencyItems = ref<ListItemBag[]>(props.paymentPlanFrequencies?.map(frequency => frequency.listItemBag) ?? []);
    const paymentPlanFrequency = ref<PaymentPlanFrequency>(noopPaymentPlanFrequency);
    const startDateIsoString = ref<string>("");
    const amountToPayToday = ref<Currency>(zeroCurrency);
    const amountToPayTodayAdjustmentCurrency = ref<Currency>(zeroCurrency);
    const amountToPayTodayPlusAdjustmentCurrency = ref<Currency>(zeroCurrency);
    const numberOfPayments = ref<number>(0);
    const numberOfPaymentsItems = ref<ListItemBag[]>([]);

    //#endregion

    //#region Computed Values

    const isPaymentPlanFrequencySelected = computed<boolean>(() => {
        return !!paymentPlanFrequency.value.transactionFrequency.definedValueGuid;
    });

    const paymentAmountMessage = computed<string>(() => {
        if (!props.paymentPlanConfiguration || props.paymentPlanConfiguration.amountPerPayment.isInvalid) {
            return "Number of Payments is required";
        }
        else {
            return `${props.paymentPlanConfiguration.amountPerPayment} Ã— ${numberOfPayments.value}`;
        }
    });

    const internalIsShown = useVModelPassthrough(props, "modelValue", emit);

    const amountToPayTodaySuffix = computed<string>(() => {
        if (amountToPayToday.value.isEqualTo(props.balanceDue)) {
            return `pay in full`;
        }
        else if (!amountToPayTodayAdjustmentCurrency.value.isZero) {
            return `added ${amountToPayTodayAdjustmentCurrency.value} to evenly distribute the remaining payments`;
        }
        else {
            return "";
        }
    });

    // const numberOfPaymentsItems = ref<ListItemBag[]>([]);() => {
    //     if (!paymentPlanFrequency.value) {
    //         // A frequency must be selected to show the number of payments list.
    //         return [];
    //     }

    //     function getNumberRange(start: number, stop: number): number[] {
    //         if (start > stop) {
    //             // Make sure start is less than stop.
    //             const oldStart = start;
    //             start = stop;
    //             stop = oldStart;
    //         }
    //         return Array(stop - start + 1).fill(0).map((v, i) => i + start);
    //     }

    //     const maxNumberOfPayments: number = paymentPlanFrequency.value.maxNumberOfPayments;
    //     const paymentPlanAmountToDivideCurrency: Currency = props.paymentPlanConfiguration?.
    //     let stop = false;
    //     const numberRange = getNumberRange(2, maxNumberOfPayments)
    //         .filter(numb => {
    //             // Remove "Number of Payments" items that would result in 0.00 per payment;
    //             // it doesn't make sense to have a payment plan where you pay 0.00 each week, month, etc.
    //             // Since the numbers are sorted in ascending order,
    //             // can filter subsequent numbers once we find one that results in 0.00 per payment.
    //             if (stop || paymentPlanAmountToDivideCurrency.value.divide(numb).quotient.isZero) {
    //                 stop = true;
    //                 return false;
    //             }
    //             else {
    //                 return true;
    //             }
    //         });

    //     // Convert the number of payments to an array of list bags.
    //     return numberRange.map(n => ({
    //         text: n.toString(),
    //         value: n.toString()
    //     }));
    // });

    //#endregion

    //#region Functions

    function validateAmountToPayTodayRule(_value: unknown, _params?: unknown[]): ValidationResult {
        if (amountToPayToday.value.isLessThan(props.paymentPlanConfiguration?.minAmountToPayToday ?? 0)) {
            return "must be greater than or equal to the minimum amount";
        }
        else {
            return true;
        }
    }

    function validateAmountToPayTodayLessThanRemaining(_value: unknown, _params?: unknown[]): ValidationResult {
        if (props.balanceDue.isLessThan(amountToPayToday.value)) {
            return "must be less than the minimum amount";
        }
        else {
            return true;
        }
    }

    function updatePaymentPlanConfiguration(overrides?: Partial<PaymentPlanConfigurationOptions>): PaymentPlanConfiguration {
        // TypeScript requires this redundant cast.
        const desiredPaymentPlanFrequency: PaymentPlanFrequency = paymentPlanFrequency.value as PaymentPlanFrequency;
        const config = getPaymentPlanConfiguration({
            amountToPayToday: amountToPayToday.value,
            balanceDue: props.balanceDue,
            desiredAllowedPaymentPlanFrequencies: props.paymentPlanFrequencies,
            desiredNumberOfPayments: numberOfPayments.value,
            desiredPaymentPlanFrequency,
            desiredStartDate: RockDateTime.parseISO(startDateIsoString.value) ?? RockDateTime.now().date,
            endDate: props.paymentDeadlineDate,
            minAmountToPayToday: props.paymentPlanConfiguration?.minAmountToPayToday ?? zeroCurrency,
            ...overrides
        });

        emit("update:paymentPlanConfiguration", config);

        return config;
    }

    function updateModal(config: PaymentPlanConfiguration): void {
        function createRange(inclusiveStart: number, inclusiveEnd: number): number[] {
            const range: number[] = [];

            for (let i = inclusiveStart; i <= inclusiveEnd; i++) {
                range.push(i);
            }

            return range;
        }

        paymentFrequencyItems.value = config.paymentPlanFrequencies.map(p => p.listItemBag);
        paymentPlanFrequency.value = config.paymentPlanFrequency;
        startDateIsoString.value = config.startDate?.toISOString() ?? "";
        numberOfPaymentsItems.value = createRange(2, config.paymentPlanFrequency.maxNumberOfPayments)
            .map(n => ({
                text: n + "",
                value: n + ""
            }));
        numberOfPayments.value = config.numberOfPayments;
        // numberOfPaymentsItems - Updated in computed ref.
        amountToPayToday.value = config.amountToPayToday;

        // Amount To Pay Today fields need to be zeroed out
        // and updated on the next tick for them to be properly update.
        amountToPayTodayAdjustmentCurrency.value = zeroCurrency;
        amountToPayTodayPlusAdjustmentCurrency.value = zeroCurrency;
        nextTick(() => {
            amountToPayTodayAdjustmentCurrency.value = config.amountToPayTodayAdjustment;
            amountToPayTodayPlusAdjustmentCurrency.value = config.amountToPayToday.add(config.amountToPayTodayAdjustment);
        });
    }

    //#endregion

    //#region Event Handlers

    function onUpdateNumberOfPaymentsStringOrEmpty(value: string | string[]): void {
        let numberOfPayments;
        if (Array.isArray(value)) {
            numberOfPayments = toNumber(value[0] ?? "");
        }
        else {
            numberOfPayments = toNumber(value);
        }

        nextTick(() => {
            updatePaymentPlanConfiguration({
                desiredNumberOfPayments: numberOfPayments
            });
        });
    }

    function onBlurAmountToPayToday(): void {
        updatePaymentPlanConfiguration();
    }

    function onUpdateAmountToPayToday(value: number | null): void {
        // Only update the ref here. DO NOT recalculate on update;
        // otherwise, the value will get overwritten on each character entered.
        // Instead, calculate on blur.
        amountToPayToday.value = createCurrency(value || 0, props.currencyOptions);
    }

    function onUpdateStartDateIsoString(value: string | null): void {
        const today = RockDateTime.now().date;
        const desiredStartDateOverride =
            value
                ? RockDateTime.parseISO(value) ?? today
                : today;

        updatePaymentPlanConfiguration({
            desiredStartDate: desiredStartDateOverride
        });
    }

    function onUpdatePaymentFrequencyGuid(guid: Guid | Guid[]): void {
        if (Array.isArray(guid)) {
            throw "Multiple payment frequencies are not supported";
        }

        updatePaymentPlanConfiguration({
            desiredPaymentPlanFrequency: props.paymentPlanFrequencies.find(p => areEqual(p.listItemBag.value, guid)) ?? noopPaymentPlanFrequency
        });
    }

    function onConfigurePaymentPlan(): void {
        // Recalc the amount to pay today one last time before setting the payment plan values.
        const config = updatePaymentPlanConfiguration();

        nextTick(() => {
            // Close the modal.
            internalIsShown.value = false;
            emit("configure", config);
        });
    }

    //#endregion

    //#region Watchers

    watch([() => props.paymentPlanConfiguration, () => props.modelValue], ([config, isShown]) => {
        if (isShown && config) {
            updateModal(config);
        }
    }, {
        immediate: true
    });

    //#endregion
</script>