<template>
    <RockFormField :modelValue="internalValue"
                   v-bind="standardProps"
                   :formGroupClasses="'rock-note-text-editor ' + formGroupClasses"
                   name="note-text-editor">
        <template #default="{ uniqueId }">
            <div ref="relativeElement" class="control-wrapper rock-text-container" style="position: relative">
                <slot name="prepend" :isInputGroupSupported="false" />

                <div :id="uniqueId">
                    <div ref="contentElement"
                         class="note-text form-control"
                         contenteditable="true"
                         spellcheck="false"
                         :placeholder="placeholder"
                         @input="onInput"
                         @blur="onBlur"
                         @paste="onPaste"
                         @keydown="onKeydown">
                    </div>
                </div>

                <div v-if="mentionPickerVisible" ref="mentionPickerElement" :style="floatingStyles" class="mention-picker">
                    <svg ref="mentionPickerArrowElement" class="arrow">
                        <path d="M0,7L5,0L10,7"></path>
                    </svg>
                    <div class="body">
                        <div ref="mentionSearchContainerElement" class="mention-search-container">
                            <div v-for="item in mentionSearchResults"
                                 class="mention-search-item"
                                 :class="{ 'active': item.identifier === currentSearchItem?.identifier }"
                                 :data-identifier="item.identifier"
                                 @click="onMentionSelect(item)"
                                 @mousedown="$event.preventDefault()"
                                 @mouseover="onMentionHover(item)">
                                <img v-if="item.imageUrl" :src="item.imageUrl" class="mention-search-item-image" loading="lazy" />
                                <div class="mention-search-item-text">
                                    <div class="mention-search-item-title">
                                        <div class="mention-search-item-name">{{ item.displayName }}</div>
                                        <div v-if="item.campusName" class="mention-search-item-campus">{{ item.campusName }}</div>
                                    </div>
                                    <div v-if="item.email" class="mention-search-item-subtitle text-muted">{{ item.email }}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <slot name="append" :isInputGroupSupported="false" />
            </div>
        </template>
    </RockFormField>
</template>

<style scoped>
.rock-text-container :deep(.popover) {
    padding: 0;
}

.rock-text-container :deep(.popover-content) {
    padding: 0;
    border-radius: 6px;
}

.note-text {
    outline: 0;
    border: 1px solid #d2d2d2;
    border-radius: var(--input-border-radius, 0);
    padding: 6px 12px;
    min-height: 88px;
    max-height: 300px;
    overflow-y: auto;
    white-space: pre-wrap;
    resize: vertical;
}

.note-text:focus {
    border: var(--focus-state-border);
}

.note-text:empty:before {
    content: attr(placeholder);
    pointer-events: none;
    color: #90949c;
}

.note-text:focus:empty:before {
    color: #bec3c9;
}

/* Probably a better way to do this, I'm not sure how though. */
.note-text:focus:before {
    content: initial;
    pointer-events: initial;
    color: initial;
}

.note-text :deep(.mention) {
    color: blue;
}

.mention-picker {
    z-index: 3;
    filter: drop-shadow(rgba(51, 51, 51, 0.533) 0 0 2px);
}

.mention-picker > .body {
    background-color: white;
    margin-top: 6px;
    border-radius: 4px;
    overflow: clip;
}

.mention-picker > .arrow {
    position: absolute;
    width: 10px;
    height: 7px;
    fill: white;
}

.mention-search-container {
    min-height: 20px;
    max-height: 200px;
    min-width: 150px;
    max-width: 320px;
    overflow-x: clip;
    overflow-y: auto;
}

.mention-search-item {
    display: flex;
    justify-items: center;
    padding: 4px 8px;
    background-color: #fff;
    cursor: pointer;
}

.mention-search-item.active {
    background-color: #f2f2f2;
}

.mention-search-item-image {
    width: 26px;
    height: 26px;
    border-radius: 13px;
    margin-right: 8px;
    align-self: center;
}

.mention-search-item-text {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
    font-size: 14px;
    line-height: 1.2em;
}

.mention-search-item-title {
    display: flex;
}

.mention-search-item-name {
    flex-grow: 1;
}

.mention-search-item-campus {
    margin-left: 8px;
    background-color: #ebe9f1;
    color: #766a81;
    font-size: 10px;
    line-height: 1em;
    padding: 2px 4px;
    border-radius: 4px;
}

.mention-search-item-subtitle {
    font-size: 12px;
}
</style>

<script setup lang="ts">
    import RockFormField from "@Obsidian/Controls/rockFormField";
    import { PropType, onMounted, ref, watch, onBeforeUnmount, Ref } from "vue";
    import { useHttp } from "@Obsidian/Utility/http";
    import { debounce } from "@Obsidian/Utility/util";
    import { standardRockFormFieldProps, useStandardRockFormFieldProps } from "@Obsidian/Utility/component";
    import { NoteEditorMentionSearchOptionsBag } from "@Obsidian/ViewModels/Rest/Controls/noteEditorMentionSearchOptionsBag";
    import { NoteEditorMentionSearchResultsBag } from "@Obsidian/ViewModels/Rest/Controls/noteEditorMentionSearchResultsBag";
    import { NoteMentionItemBag } from "@Obsidian/ViewModels/Controls/noteMentionItemBag";
    import { arrow, shift, useFloating, VirtualElement } from "@Obsidian/Libs/floating-ui";

    const props = defineProps({
        modelValue: {
            type: String as PropType<string>,
            default: ""
        },

        placeholder: {
            type: String as PropType<string>,
            required: false
        },

        mentionEnabled: {
            type: Boolean as PropType<boolean>,
            default: false
        },

        ...standardRockFormFieldProps
    });

    const standardProps = useStandardRockFormFieldProps(props);

    const emit = defineEmits<{
        (e: "update:modelValue", value: string): void;
    }>();

    const http = useHttp();
    const contentElement = ref<HTMLElement>();
    const relativeElement = ref<HTMLElement>();
    const mentionSearchContainerElement = ref<HTMLElement>();
    const mentionPickerElement = ref<HTMLElement>();
    const mentionPickerArrowElement = ref<HTMLElement>();
    const floatingReference = ref<VirtualElement>();
    const internalValue = ref<string>(props.modelValue ?? "");
    const mentionPickerVisible = ref(false);
    const mentionSearchResults = ref<NoteMentionItemBag[]>([]);
    const currentSearchItem = ref<NoteMentionItemBag>();
    const mentionStart = ref(0);
    const performSearch = debounce(() => searchForMentions(), 350, false);
    let searchCancellationToken: Ref<boolean> | null = null;

    const { floatingStyles, middlewareData } = useFloating(floatingReference, mentionPickerElement, {
        middleware: [
            shift(),
            arrow({
                element: mentionPickerArrowElement
            })
        ]
    });


    // #region Functions

    /**
     * Update the content from our model value.
     */
    function updateContent(): void {
        if (contentElement.value) {
            contentElement.value.innerHTML = props.modelValue || "";
        }
    }

    /**
     * Emit the new model value to match our internal content.
     */
    function updateModelValue(): void {
        const newValue = getCurrentContent();
        internalValue.value = newValue;

        if (newValue !== props.modelValue) {
            emit("update:modelValue", newValue);
        }
    }

    /**
     * Gets the current content HTML of the editor.
     */
    function getCurrentContent(): string {
        let value = contentElement.value?.innerHTML ?? "";

        // Browsers sometimes put a trailing break at the end of the
        // content. This seems to happen with certain combinations of
        // line feeds and then backspacing.
        if (value.endsWith("<br>")) {
            value = value.substring(0, value.length - 4);
        }

        return value;
    }

    /**
     * Moves the selection (cursor) to just after the specified node.
     *
     * @param afterNode The node that the selection should be moved after.
     */
    function moveSelectionAfter(afterNode: Node): void {
        const selection = window.getSelection();

        if (!selection) {
            return;
        }

        const newRange = document.createRange();

        if (afterNode.nextSibling instanceof Text) {
            newRange.setStart(afterNode.nextSibling, 0);
            newRange.setEnd(afterNode.nextSibling, 0);
        }
        else {
            newRange.setStartAfter(afterNode);
        }

        selection.removeAllRanges();
        selection.addRange(newRange);
    }

    /**
     * Gets the pixel position of the caret. The coordinates are returned
     * relative to the document.
     */
    function getCaretPixelPosition(): { x: number, y: number } | undefined {
        const selection = window.getSelection();
        if (!selection || selection.rangeCount <= 0) {
            return undefined;
        }

        const range = selection.getRangeAt(0);
        let rect: DOMRect | undefined;

        if (range.startContainer instanceof Text) {
            rect = range.getBoundingClientRect();
        }
        else if (range.startOffset < range.startContainer.childNodes.length) {
            const childNode = range.startContainer.childNodes[range.startOffset];

            if (childNode instanceof HTMLElement) {
                rect = childNode.getBoundingClientRect();
            }
        }

        if (!rect) {
            return {
                x: 0,
                y: 0
            };
        }

        return {
            x: rect.left,
            y: rect.bottom
        };
    }

    /**
     * Updates the popover position based on the current caret position.
     */
    function updatePopoverPosition(): void {
        const caretPos = getCaretPixelPosition();

        if (caretPos) {
            floatingReference.value = {
                getBoundingClientRect() {
                    return {
                        width: 0,
                        height: 0,
                        x: caretPos.x,
                        y: caretPos.y,
                        left: caretPos.x,
                        top: caretPos.y,
                        right: caretPos.x,
                        bottom: caretPos.y
                    };
                }
            };
        }
    }

    /**
     * Gets the current text in the mention we are currently performing.
     */
    function getCurrentMentionText(): string {
        const selection = document.getSelection();

        if (!selection || !(selection.anchorNode instanceof Text)) {
            return "";
        }

        const anchorText = selection.anchorNode.textContent ?? "";
        let text = "";

        for (let i = selection.anchorOffset - 1; i >= 0; i--) {
            if (anchorText[i] === "@") {
                break;
            }

            text = `${anchorText[i]}${text}`;
        }

        return text;
    }

    /**
     * Performs a search for possible mentions to display to the individual
     * so they can pick one.
     *
     * @param needle The partial mention text to search for.
     */
    async function searchForMentions(): Promise<void> {
        if (!mentionPickerVisible.value) {
            return;
        }

        const cancellationToken = ref(false);

        if (searchCancellationToken) {
            searchCancellationToken.value = true;
        }

        searchCancellationToken = cancellationToken;

        const options: NoteEditorMentionSearchOptionsBag = {
            name: getCurrentMentionText()
        };

        const response = await http.post<NoteEditorMentionSearchResultsBag>("/api/v2/Controls/NoteEditorMentionSearch", undefined, options);

        if (!response.isSuccess || !response.data) {
            return;
        }

        // Check if we have been cancelled.
        if (cancellationToken.value) {
            return;
        }

        mentionSearchResults.value = response.data.items ?? [];

        // Make sure it is still a valid selection.
        currentSearchItem.value = mentionSearchResults.value
            .find(r => r.identifier === currentSearchItem.value?.identifier);

        // If no selection, select the first item.
        if (!currentSearchItem.value && mentionSearchResults.value.length > 0) {
            currentSearchItem.value = mentionSearchResults.value[0];
        }
    }

    /**
     * Called when a keydown event happens while we are in the middle of
     * creating a new mention.
     *
     * @param selection The current selection in the editor.
     * @param event The keyboard event.
     */
    function handlePopoverKeydown(selection: Selection, event: KeyboardEvent): void {
        // Check for special keys that abort the process.
        if (event.key === "@" || event.key === "," || event.key === "." || event.key === "Escape") {
            mentionPickerVisible.value = false;
            return;
        }

        // Ignore meta keys.
        if (event.key === "Shift" || event.key === "Control" || event.key === "Alt" || event.key === "OS") {
            return;
        }

        // Ignore other keys.
        if (event.key === "Backspace") {
            return;
        }

        // Handle moving up and down the result list.
        if (event.key === "ArrowUp" || event.key === "ArrowDown") {
            event.preventDefault();

            if (mentionSearchResults.value.length === 0) {
                return;
            }

            const index = mentionSearchResults.value.findIndex(r => r.identifier === currentSearchItem.value?.identifier);

            if (index === -1) {
                currentSearchItem.value = mentionSearchResults.value.length > 0 ? mentionSearchResults.value[0] : undefined;
            }
            else if (event.key === "ArrowDown" && index + 1 < mentionSearchResults.value.length) {
                currentSearchItem.value = mentionSearchResults.value[index + 1];
            }
            else if (event.key === "ArrowUp" && index - 1 >= 0) {
                currentSearchItem.value = mentionSearchResults.value[index - 1];
            }

            if (currentSearchItem.value && mentionSearchContainerElement.value) {
                const el = mentionSearchContainerElement.value
                    .querySelector(`[data-identifier='${currentSearchItem.value.identifier}']`);

                if (el) {
                    el.scrollIntoView({ behavior: "smooth", block: "nearest", inline: "start" });
                }
            }

            return;
        }

        if (event.key === "Enter") {
            event.preventDefault();

            if (!(selection.anchorNode instanceof Text) || !currentSearchItem.value) {
                mentionPickerVisible.value = false;
                return;
            }

            insertMention(selection, currentSearchItem.value);
            mentionPickerVisible.value = false;

            return;
        }

        // If anything else but a character comes in, abort the search.
        if (event.key.length > 1) {
            console.log(`Aborting mention on '${event.key}'.`);
            mentionPickerVisible.value = false;
        }
    }

    /**
     * Inserts a mention at the current cursor position. This finds the start
     * of the mention and removes the temporary mention text and then replaces
     * it with the proper mention HTML.
     *
     * @param selection The current cursor position.
     * @param mentionItem The mention item to be inserted.
     */
    function insertMention(selection: Selection, mentionItem: NoteMentionItemBag): void {
        const mentionText = getCurrentMentionText();

        // Create a new selection that contains the current mention text.
        const range = selection.getRangeAt(0);
        const newRange = document.createRange();
        newRange.setStart(range.startContainer, range.startOffset - mentionText.length - 1);
        newRange.setEnd(range.endContainer, range.endOffset);
        selection.removeAllRanges();
        selection.addRange(newRange);

        newRange.deleteContents();

        if (mentionItem.displayName && mentionItem.identifier) {
            const mention = document.createElement("span");
            mention.innerText = `@${mentionItem.displayName}`;
            mention.classList.add("mention");
            mention.dataset["identifier"] = mentionItem.identifier;

            newRange.insertNode(mention);

            moveSelectionAfter(mention);
        }

        updateModelValue();
    }

    /**
     * Finds the anchor position in the text. Basically, this ignores all HTML
     * formatting and gets the plain text string. Then determines the offset
     * into that plain text string that the cursor position would be at.
     *
     * @param selection The current selection.
     */
    function getAnchorPositionInText(selection: Selection): number {
        if (!selection.anchorNode || !contentElement.value || !contentElement.value.contains(selection.anchorNode)) {
            return 0;
        }

        if (selection.rangeCount === 0) {
            return 0;
        }

        let position = selection.anchorOffset;

        const realRange = selection.getRangeAt(0);
        const range = realRange.cloneRange();
        range.selectNodeContents(contentElement.value);
        range.setEnd(realRange.endContainer, realRange.endOffset);
        position = range.toString().length;

        return position;
    }

    // #endregion

    // #region Event Handlers

    /**
     * Event handler for when an input event is triggered on the content editor.
     */
    function onInput(): void {
        updateModelValue();

        if (mentionPickerVisible.value) {
            performSearch();
            updatePopoverPosition();
        }
    }

    /**
     * Event handler for when the content editor has lost keyboard focus.
     */
    function onBlur(): void {
        updateModelValue();
    }

    /**
     * Event handler for when data is pasted into the content editor.
     *
     * @param event The event that describes the clipboard contents.
     */
    function onPaste(event: ClipboardEvent): void {
        event.preventDefault();

        // Hide the mention picker on paste.
        if (mentionPickerVisible.value) {
            mentionPickerVisible.value = false;
        }

        // If we don't have plain text then ignore the paste.
        const text = event.clipboardData?.getData("text/plain");
        if (!text) {
            return;
        }

        const sel = window.getSelection();
        if (sel) {
            const range = sel.getRangeAt(0);
            const textNode = document.createTextNode(text);

            range.deleteContents();
            range.insertNode(textNode);

            moveSelectionAfter(textNode);
            updateModelValue();
        }
    }

    /**
     * Event handler for when the keydown event is triggered on the content
     * editor.
     *
     * @param event The keyboard event representing the key that was pressed.
     */
    function onKeydown(event: KeyboardEvent): void {
        const sel = window.getSelection();

        if (!sel) {
            return;
        }

        if (mentionPickerVisible.value) {
            handlePopoverKeydown(sel, event);

            return;
        }

        if (event.key === "Enter") {
            // Prevent the normal handler so we can insert a plain text
            // newline character.
            event.preventDefault();

            const range = sel.getRangeAt(0);
            const textNode = document.createTextNode("\n");

            range.deleteContents();
            range.insertNode(textNode);

            moveSelectionAfter(textNode);
            updateModelValue();
        }
        else if (event.key === "@" && props.mentionEnabled) {
            mentionStart.value = getAnchorPositionInText(sel);
            mentionPickerVisible.value = true;
            mentionSearchResults.value = [];
            currentSearchItem.value = undefined;
        }
        else if (event.key === "Backspace" && sel.anchorNode) {
            let targetNode: Node | null = null;

            // Determine which node to target for deletion. This is a little
            // complicated because we might be sitting on a text node, an HTML
            // node or a boundary between two nodes.
            if (sel.anchorNode.parentElement instanceof HTMLElement && sel.anchorNode.parentElement.classList.contains("mention")) {
                targetNode = sel.anchorNode.parentElement;
            }
            else if (sel.anchorNode instanceof Text) {
                if (sel.anchorOffset > 0) {
                    return;
                }

                targetNode = sel.anchorNode.previousSibling;
            }
            else if (sel.anchorNode instanceof HTMLElement) {
                targetNode = sel.anchorNode.childNodes[sel.anchorOffset - 1];
            }

            // If the target node to be deleted is a mention, then delete the
            // whole mention instead.
            if (targetNode instanceof HTMLElement && targetNode.classList.contains("mention")) {
                event.preventDefault();
                targetNode.remove();
                updateModelValue();
            }
        }
        else if (event.key === "Delete" && sel.anchorNode) {
            let targetNode: Node | null = null;

            // Determine which node to target for deletion. This is a little
            // complicated because we might be sitting on a text node, an HTML
            // node or a boundary between two nodes.
            if (sel.anchorNode.parentElement instanceof HTMLElement && sel.anchorNode.parentElement.classList.contains("mention")) {
                targetNode = sel.anchorNode.parentElement;
            }
            else if (sel.anchorNode instanceof Text) {
                if (sel.anchorOffset < (sel.anchorNode.textContent ?? "").length) {
                    return;
                }

                targetNode = sel.anchorNode.nextSibling;
            }
            else if (sel.anchorNode instanceof HTMLElement && sel.anchorOffset + 1 < sel.anchorNode.childNodes.length) {
                targetNode = sel.anchorNode.childNodes[sel.anchorOffset + 1];
            }

            // If the target node to be deleted is a mention, then delete the
            // whole mention instead.
            if (targetNode instanceof HTMLElement && targetNode.classList.contains("mention")) {
                event.preventDefault();
                targetNode.remove();
                updateModelValue();
            }
        }
    }

    /**
     * Event handler for when the selection inside this document has changed.
     */
    function onDocumentSelectionChange(): void {
        const selection = document.getSelection();

        if (!selection) {
            return;
        }

        for (let i = 0; i < selection.rangeCount; i++) {
            const range = selection.getRangeAt(i);

            // If we are currently entering a mention, see if the new selection
            // position should abort the process.
            if (mentionPickerVisible.value) {
                const position = getAnchorPositionInText(selection);

                // Selecting a range, not allowed.
                if (range.startContainer !== range.endContainer || range.startOffset !== range.endOffset) {
                    mentionPickerVisible.value = false;
                }

                // Moving before the start of the mention or 15 characters past
                // the mention. Not allowed.
                if (position <= mentionStart.value || position > mentionStart.value + 15) {
                    mentionPickerVisible.value = false;
                }
            }

            // If they are selecting part of an existing mention, make sure
            // the whole thing gets selected.
            if (range.startContainer.parentElement instanceof HTMLElement && range.startContainer.parentElement.classList.contains("mention")) {
                range.setStartBefore(range.startContainer.parentElement);
            }

            // Ditto for the end range.
            if (range.endContainer.parentElement instanceof HTMLElement && range.endContainer.parentElement.classList.contains("mention")) {
                range.setEndAfter(range.endContainer.parentElement);
            }
        }
    }

    /**
     * Event handler for when a mention is selected by click event.
     *
     * @param mention The mention that was selected.
     */
    function onMentionSelect(mention: NoteMentionItemBag): void {
        const sel = window.getSelection();

        if (sel) {
            insertMention(sel, mention);
        }

        mentionPickerVisible.value = false;
    }

    /**
     * Event handler for when a mention is hovered by the mouse.
     *
     * @param mention The mention that was hovered over.
     */
    function onMentionHover(mention: NoteMentionItemBag): void {
        // Mark the hovered mention as selected.
        currentSearchItem.value = mention;
    }

    // #endregion

    // Watch for changes from the parent component.
    watch(() => props.modelValue, () => {
        if (props.modelValue !== getCurrentContent()) {
            updateContent();
        }
    });

    // Watch for the middleware data about the arrow to change and then
    // update the arrow position.
    watch(middlewareData, () => {
        if (middlewareData.value.arrow && mentionPickerArrowElement.value) {
            mentionPickerArrowElement.value.style.left = `${middlewareData.value.arrow.x ?? 0}px`;
        }
    });

    onMounted(() => {
        updateContent();

        document.addEventListener("selectionchange", onDocumentSelectionChange);
    });

    onBeforeUnmount(() => {
        document.removeEventListener("selectionchange", onDocumentSelectionChange);
    });

    watch(contentElement, () => {
        // This handles cases where the contentElement gets destroyed and
        // re-created without us being remounted. This can happen if the label
        // text changes from blank to non-blank or vice-versa.
        if (contentElement.value && internalValue.value) {
            contentElement.value.innerHTML = internalValue.value;
        }
    });
</script>
