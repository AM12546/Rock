<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <RockFormField v-model="internalValue" :formGroupClasses="`html-editor ${formGroupClasses}`" name="html-editor">
        <template #default="{ uniqueId, field }">
            <div class="control-wrapper">
                <div class="note-editor-container">
                    <div class="note-editor note-frame panel panel-default">
                        <div :id="assignToolbarId(uniqueId)" class="panel-heading note-toolbar" ref="toolbar"></div>
                        <div class="note-editing-area" ref="editingArea">
                            <div v-show="!editSourceCode" :id="assignEditorId(uniqueId)" class="note-editable"></div>
                            <CodeEditor v-if="editSourceCode"
                                        v-model="internalValue"
                                        :disabled="disabled"
                                        :editorHeight="editorHeight + yOffset"
                                        mode="html" />
                        </div>
                        <div class="note-statusbar" ref="resizer" role="status">
                            <div class="note-resizebar" aria-label="Resize">
                                <div class="note-icon-bar"></div>
                                <div class="note-icon-bar"></div>
                                <div class="note-icon-bar"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <Modal v-model="showMergeFieldModal"
                   cancelText="Cancel"
                   saveText="OK"
                   title="Select Merge Field"
                   :onSave="onMergeFieldPicked">
                <MergeFieldPicker v-model="mergeFieldValue"
                                  :additionalFields="mergeFields ?? ''"
                                  :multiple="false"
                                  placeholder="Add Merge Field" />
            </Modal>
            <Modal v-model="showPasteAsPlainTextModal"
                   title="Paste as Plain Text"
                   cancelText=""
                   saveText="Insert"
                   :onSave="onPasteAsPlainText">
                <TextBox v-model="pasteAsPlainTextValue"
                         label="Paste the content below, then press the Insert button to insert the content as plain text."
                         textMode="multiline"
                         :rows="10" />
            </Modal>
        </template>
    </RockFormField>
</template>

<style scoped>
:deep(.tox.tox-tinymce-inline .tox-editor-header) {
    border: none;
}

.note-editable {
    height: v-bind(editorHeightCss);
}

.note-editor-container {
    position: relative;
}

.note-editor .note-toolbar {
    padding: 0;
}
</style>

<script setup lang="ts">
    import { PropType, computed, onMounted, onUnmounted, ref, watch, watchEffect } from "vue";
    import CodeEditor from "./codeEditor.obs";
    import MergeFieldPicker from "./mergeFieldPicker.obs";
    import Modal from "./modal.obs";
    import RockFormField from "./rockFormField.obs";
    import TextBox from "./textBox.obs";
    import { tinymce, Editor, EditorEvent, Events, Ui } from "@Obsidian/Libs/tinymce";
    import { useVModelPassthrough } from "@Obsidian/Utility/component";
    import { ListItemBag } from "@Obsidian/ViewModels/Utility/listItemBag";

    const props = defineProps({
        /** The HTML value. */
        modelValue: {
            type: String as PropType<string>,
            required: true
        },

        /** Custom classes to add to the form group. */
        formGroupClasses: {
            type: String as PropType<string>,
            default: ""
        },

        /** Whether or not to disable the control. */
        disabled: {
            type: Boolean as PropType<boolean>,
            default: false
        },

        /** Initial HTML value for the control. Not used if modelValue has a value at initialization. */
        initialValue: {
            type: String as PropType<string | null | undefined>,
        },

        /**
         * Comma-delimited merge fields available for selection.
         * This should include either a list of entity type names (full name), or other non-object string values.
         *
         * Format should be one of the following:
         * @example
         * "FieldName" // Label will be a case-delimited version of FieldName (i.e. "Field Name")
         * "FieldName|Label" // Same as previous but with a custom label.
         * "FieldName^EntityType" // Will evaluate the entity type and add a navigable tree for the object's properties and attributes. Label will be a case delimited version of FieldName (i.e. "Field Name").
         * "FieldName^EntityType|Label" // Same as previous but with a custom label.
         */
        mergeFields: {
            type: String as PropType<string | null | undefined>,
            default: ""
        },

        /** Editor height in pixels (not including toolbar). */
        editorHeight: {
            type: Number as PropType<number>,
            default: 600
        }
    });

    const emit = defineEmits<{
        (e: "update:modelValue", value: string): void;
    }>();

    // #region Values

    const internalValue = useVModelPassthrough(props, "modelValue", emit);
    const editorId = ref<string>();
    const toolbarId = ref<string>();
    const tinyMceInstance = ref<Editor>();
    const editorValue = ref<string>();
    const resizer = ref<HTMLElement>();
    const editingArea = ref<HTMLElement>();
    const yOffset = ref<number>(0);
    const toolbar = ref<HTMLElement>();

    // #region Plugin - Edit Source Code.

    const editSourceCode = ref<boolean>(false);
    const rockEditSourceCodePlugin = {
        init(editor: Editor): void {
            // Register toolbar buttons.
            editor.ui.registry.addToggleButton(rockEditSourceCodePlugin.toolbar.editSourceCode, {
                icon: "sourcecode",
                enabled: true,
                tooltip: "Code Editor",
                onAction: (api: Ui.Toolbar.ToolbarToggleButtonInstanceApi): void => {
                    editSourceCode.value = !editSourceCode.value;
                    api.setActive(editSourceCode.value);
                }
            });
        },
        toolbar: {
            editSourceCode: "rockeditsourcecode"
        } as const
    } as const;

    // #endregion

    // #region Plugin - Paste As Plain Text.

    const showPasteAsPlainTextModal = ref<boolean>(false);
    const pasteAsPlainTextValue = ref<string>("");
    function onPasteAsPlainText(): void {
        const editor = tinyMceInstance.value;
        if (!editor) {
            // Skip if the editor is not initialized.
            return;
        }

        // Create a temporary div element that will be used to get the text content of the pasted value.
        const temporaryDiv = document.createElement("div");
        temporaryDiv.innerHTML = pasteAsPlainTextValue.value;

        // Paste the content into the editor at the current position.
        editor.insertContent(temporaryDiv.textContent ?? "");

        // Clear the pasted value and close the modal.
        pasteAsPlainTextValue.value = "";
        showPasteAsPlainTextModal.value = false;
    }
    const rockPasteAsPlainTextPlugin = {
        init: (editor: Editor): void => {
            // Register toolbar buttons.
            editor.ui.registry.addToggleButton(rockPasteAsPlainTextPlugin.toolbar.pasteAsPlainText, {
                icon: "paste-text",
                tooltip: "Paste Text",
                onAction: (_api: Ui.Toolbar.ToolbarButtonInstanceApi): void => {
                    showPasteAsPlainTextModal.value = true;
                }
            });
        },
        toolbar: {
            pasteAsPlainText: "rockpasteasplaintext"
        } as const
    } as const;

    // #endregion

    // #region Plugin - Paragraph.

    const rockParagraphPlugin = {
        init: (editor: Editor): void => {
            /** Paragraph button definition. */
            type ParagraphButton = {
                /** The text that will be displayed on the menu item. */
                text: string;
                /** The menu item icon. */
                icon: string;
                /** The TinyMCE magic format string. */
                format: string;
                /** The shortcut (displayed as a label and adds shortcut functionality). */
                shortcut: string;
                /** The shortcut description. */
                shortcutDescription: string;
                /** The command to execute when clicked. */
                command: string;
                /** The initialized button instance. */
                button?: Ui.Menu.NestedMenuItemContents | undefined;
                /** Cleans up resources used by the button. */
                destroy?: () => void;
            };

            /** Paragraph button definitions. */
            const paragraphButtons: {
                [key: string]: ParagraphButton
            } = {
                "left": {
                    text: "Align left",
                    format: "alignleft",
                    icon: "align-left",
                    shortcut: "Meta+Shift+L",
                    shortcutDescription: "Left aligns the current text block/image.",
                    command: "JustifyLeft"
                },
                "center": {
                    text: "Align center",
                    format: "aligncenter",
                    icon: "align-center",
                    shortcut: "Meta+Shift+E",
                    shortcutDescription: "Center aligns the current text block/image.",
                    command: "JustifyCenter"
                },
                "right": {
                    text: "Align right",
                    format: "alignright",
                    icon: "align-right",
                    shortcut: "Meta+Shift+R",
                    shortcutDescription: "Right aligns the current text block/image.",
                    command: "JustifyRight"
                },
                "justify": {
                    text: "Justify full",
                    format: "alignjustify",
                    icon: "align-justify",
                    shortcut: "Meta+Shift+J",
                    shortcutDescription: "Full aligns the current text block/image.",
                    command: "JustifyFull"
                },
                "outdent": {
                    text: "Outdent",
                    format: "outdent",
                    icon: "outdent",
                    shortcut: "Meta+Shift+O",
                    shortcutDescription: "Outdents the current selection.",
                    command: "Outdent"
                },
                "indent": {
                    text: "Indent",
                    format: "indent",
                    icon: "indent",
                    shortcut: "Meta+Shift+I",
                    shortcutDescription: "Indents the current selection.",
                    command: "Indent"
                },
            } as const;

            /** Helper function that registers a paragraph button shortcut. */
            function registerShortcut(paragraphButton: ParagraphButton): void {
                editor.addShortcut(paragraphButton.shortcut, paragraphButton.shortcutDescription, () => {
                    editor.execCommand(paragraphButton.command);
                });
            }

            // Register toolbar buttons.
            // This combines the functionality of the built-in `align` toolbar button
            // and the `indent` toolbar button. It also updates the toolbar icon to
            // reflect the alignment of the selected node.
            editor.ui.registry.addMenuButton(rockParagraphPlugin.toolbar.paragraph, {
                icon: "align-left",
                tooltip: "Paragraph",
                onSetup: (api: Ui.Toolbar.ToolbarMenuButtonInstanceApi) => {
                    const rockparagraphItems: Record<string, string> = {
                        "alignleft": "align-left",
                        "alignright": "align-right",
                        "aligncenter": "align-center",
                        "alignjustify": "align-justify"
                    };

                    // Watch for node change events.
                    const eventDispatcher = editor.on("NodeChange", () => {
                        const keys = Object.keys(rockparagraphItems);
                        for (const key of keys) {
                            // https://www.tiny.cloud/docs/tinymce/6/content-formatting/#built-in-formats
                            if (editor.formatter.match(key)) {
                                api.setIcon(rockparagraphItems[key]);
                                api.setActive(true);
                                return;
                            }
                        }

                        // No alignment formats are active,
                        // so reset the icon and the active state of the toolbar button.
                        api.setIcon("align-left");
                        api.setActive(false);
                    });

                    return (_api: Ui.Toolbar.ToolbarMenuButtonInstanceApi): void => {
                        // Unregister event handlers and destroy buttons.
                        eventDispatcher.off();
                        paragraphButtons.left.destroy?.();
                        paragraphButtons.center.destroy?.();
                        paragraphButtons.right.destroy?.();
                        paragraphButtons.justify.destroy?.();
                        paragraphButtons.outdent.destroy?.();
                        paragraphButtons.indent.destroy?.();
                    };
                },
                fetch: (callback, _, paragraphApi) => {
                    // This hook will return the menu items for the toolbar button.

                    /** Helper function that creates a toggle menu item button. */
                    function createToggleMenuItem(paragraphButton: ParagraphButton): Ui.Menu.NestedMenuItemContents {
                        // Only create the button once to avoid multiple event registrations.
                        if (!paragraphButton.button) {
                            let formatChangedHandle: undefined | {
                                unbind(): void;
                            };
                            paragraphButton.button = {
                                type: "togglemenuitem",
                                text: paragraphButton.text,
                                icon: paragraphButton.icon,
                                // Shortcut label (does not add a shortcut).
                                shortcut: paragraphButton.shortcut,
                                onAction: (_api: Ui.Menu.ToggleMenuItemInstanceApi): void => {
                                    editor.formatter.apply(paragraphButton.format);
                                },
                                // https://www.tiny.cloud/docs/tinymce/6/custom-toggle-toolbar-button/#using-onsetup
                                onSetup: (api: Ui.Menu.ToggleMenuItemInstanceApi): void => {
                                    // Only allow this callback to run once.
                                    // The formatChanged event registration causes console warning if this is run multiple times.
                                    if (!paragraphButton.button) {
                                        // Check if the icon should be changed once the `rockparagraph` toolbar button is clicked.
                                        const isActive = editor.formatter.match(paragraphButton.format);
                                        api.setActive(isActive);
                                        if (isActive) {
                                            paragraphApi.setIcon(paragraphButton.icon);
                                        }

                                        // When the format changes, set the toolbar button as active
                                        // and update the icon to show the selected format.
                                        formatChangedHandle = editor.formatter.formatChanged(paragraphButton.format, (state) => {
                                            api.setActive(state);
                                            if (state) {
                                                paragraphApi.setIcon(paragraphButton.icon);
                                            }
                                        });
                                    }
                                }
                            } as Ui.Menu.ToggleMenuItemSpec;
                            paragraphButton.destroy = () => {
                                // Unregister event handlers and remove the button.
                                formatChangedHandle?.unbind();
                                paragraphButton.button = undefined;
                            };
                        }

                        return paragraphButton.button;
                    }

                    /** Helper function that creates a plain menu item button. */
                    function createMenuItem(paragraphButton: ParagraphButton): Ui.Menu.NestedMenuItemContents {
                        // Only create the button once to avoid multiple event registrations.
                        if (!paragraphButton.button) {
                            paragraphButton.button = {
                                type: "menuitem",
                                text: paragraphButton.text,
                                icon: paragraphButton.icon,
                                // Shortcut label (does not add a shortcut).
                                shortcut: paragraphButton.shortcut,
                                onAction: (_api: Ui.Menu.MenuItemInstanceApi): void => {
                                    editor.execCommand(paragraphButton.command);
                                }
                            } as Ui.Menu.MenuItemSpec;
                            paragraphButton.destroy = () => {
                                // Unregister event handlers and remove the button.
                                paragraphButton.button = undefined;
                            };
                        }
                        return paragraphButton.button;
                    }

                    // Pass the menu item button config to the callback to create the toolbar children buttons.
                    callback([
                        createToggleMenuItem(paragraphButtons.left),
                        createToggleMenuItem(paragraphButtons.center),
                        createToggleMenuItem(paragraphButtons.right),
                        createToggleMenuItem(paragraphButtons.justify),
                        createMenuItem(paragraphButtons.outdent),
                        createMenuItem(paragraphButtons.indent)
                    ]);
                }
            });

            // Register shortcuts.
            registerShortcut(paragraphButtons.left);
            registerShortcut(paragraphButtons.center);
            registerShortcut(paragraphButtons.right);
            registerShortcut(paragraphButtons.justify);
            registerShortcut(paragraphButtons.outdent);
            registerShortcut(paragraphButtons.indent);
        },
        toolbar: {
            paragraph: "rockparagraph"
        } as const
    };

    // #endregion

    // #region Plugin - Merge Field.

    const showMergeFieldModal = ref<boolean>(false);
    const mergeFieldValue = ref<ListItemBag | undefined>();

    /** Event handler for a merge field being selected in the Select Merge Field modal. */
    function onMergeFieldPicked(): void {
        const editor = tinyMceInstance.value;

        if (!editor) {
            // Skip if the editor is not initialized.
            return;
        }

        const mergeField = mergeFieldValue.value;

        if (!mergeField?.value) {
            // Skip if no merge field was selected.
            return;
        }

        // Insert the merge field value into the editor at the current position.
        editor.insertContent(`{{ ${mergeField.value} }}`);

        // Clear the merge field and close the modal.
        mergeFieldValue.value = undefined;
        showMergeFieldModal.value = false;
    }

    // Define `rockmergefields` toolbar button.
    const rockMergeFieldPlugin = {
        init: (editor: Editor): void => {
            const tooltip = "Merge Field";

            function showOrHideToolbarButton(value: string | null | undefined): void {
                const mergeFieldButton = getToolbarButton(tooltip);

                if (mergeFieldButton) {
                    // Set the CSS display value depending on whether there is a value.
                    const display = value ? "" : "none";
                    mergeFieldButton.style.display = display;

                    // Also set the toolbar button group display if this is the only button in the button group.
                    const parentElement = mergeFieldButton.parentElement;
                    if (parentElement?.classList.contains("tox-toolbar__group") && parentElement.children.length === 1) {
                        parentElement.style.display = display;
                    }
                }
            }

            // Hide or show the toolbar button when the mergeFields change.
            const stopWatching = watch(() => props.mergeFields, (value: string | null | undefined) => {
                showOrHideToolbarButton(value);
            });

            editor.ui.registry.addButton(rockMergeFieldPlugin.toolbar.mergeField, {
                icon: "code-sample",
                tooltip: tooltip,
                onAction: (_api: Ui.Toolbar.ToolbarButtonInstanceApi): void => {
                    showMergeFieldModal.value = true;
                },
                onSetup: (_apiAtSetup: Ui.Toolbar.ToolbarButtonInstanceApi): (api: Ui.Toolbar.ToolbarButtonInstanceApi) => void => {
                    showOrHideToolbarButton(props.mergeFields);

                    // Return a cleanup function that stops watching the mergeFields prop.
                    return (_apiAtCleanup: Ui.Toolbar.ToolbarButtonInstanceApi) => {
                        stopWatching?.();
                    };
                }
            });
        },
        toolbar: {
            mergeField: "rockmergefield"
        } as const
    };

    // #endregion

    // #endregion

    // #region Computed Values

    const editorHeightCss = computed<string>(() => `${props.editorHeight + yOffset.value}px`);

    // #endregion

    // #region Functions

    /** Returns the ID assigned to the editor HTML element. */
    function assignEditorId(uniquePart: string): string {
        editorId.value = `html-editor-container-${uniquePart}`;
        return editorId.value;
    }

    /** Returns the ID assigned to the editor toolbar HTML element. */
    function assignToolbarId(uniquePart: string): string {
        toolbarId.value = `html-editor-toolbar-container-${uniquePart}`;
        return toolbarId.value;
    }

    /** Gets a button element from the toolbar. This should only be called after the editor is initialized. */
    function getToolbarButton(tooltip: string): HTMLElement | null | undefined {
        // The only identifier TinyMCE adds to a toolbar button is the title (tooltip) attribute.
        // This function will need to be updated if a newer version of the TinyMCE library
        // is used and does things differently (doesn't add the tox-tbtn class or set the title attribute).
        return toolbar.value?.querySelector(`.tox-tbtn[title='${tooltip}']`) as HTMLElement;
    }

    // #endregion

    // #region Event Handlers

    /** Event handler for the mouse being pressed while the pointer is inside the resize element. This starts the resize behavior. */
    function onResizeStart(_event: MouseEvent): void {
        document.addEventListener("mousemove", onResize);
        document.addEventListener("mouseup", onResizeEnd, { once: true });
    }

    /** Event handler for the mouse being moved while the resizer is being dragged. This resizes the editor. */
    function onResize(event: MouseEvent): void {
        yOffset.value += event.movementY;
    }

    /** Event handler for the mouse being released while the resizer is being dragged. This ends the resize behavior. */
    function onResizeEnd(_event: MouseEvent): void {
        document.removeEventListener("mousemove", onResize);
        resizer.value?.addEventListener("mousedown", onResizeStart, { once: true });
    }

    // #endregion

    // #region Watchers

    // Update the editor content when the model value changes externally.
    watchEffect(() => {
        if (tinyMceInstance.value && editorValue.value !== internalValue.value) {
            tinyMceInstance.value.setContent(internalValue.value);

            // Get the new content from the editor after setting it
            // just in case it gets manipulated by plugins.
            editorValue.value = tinyMceInstance.value.getContent();
        }
    }, {
        // "post" will cause the effect to initially execute after the DOM is updated (after the editor is initialized).
        flush: "post"
    });

    // Clear the resize offset when the `editorHeight` prop changes.
    watch(() => props.editorHeight, () => {
        yOffset.value = 0;
    });

    // Disable the editor when the `disabled` prop changes.
    watchEffect(() => {
        if (tinyMceInstance.value) {
            // Disable the toolbar and border.
            tinyMceInstance.value.ui?.setEnabled(!props.disabled);

            // Disable the content.
            const editorBody = tinyMceInstance.value.getBody();
            if (editorBody) {
                editorBody.setAttribute("contenteditable", `${!props.disabled}`);
            }
        }
    }, {
        // "post" will cause the effect to initially execute after the DOM is updated (after the editor is initialized).
        flush: "post"
    });

    // Initialize the editor.
    onMounted(() => {
        if (editorId.value && toolbarId.value) {
            tinymce.init({
                // Add the editor directly to the target element (instead of in an iframe)
                // by configuring an inline editor with a fixed toolbar.
                // An inline editor is preferred so the editor will inherit the Rock styles
                // and have access to the same APIs loaded in the page.
                // https://www.tiny.cloud/docs/tinymce/6/toolbar-configuration-options/#persistent-inline-editor-toolbar-options
                selector: `#${editorId.value}`,
                inline: true,
                fixed_toolbar_container: `#${toolbarId.value}`,
                toolbar_persist: true,
                toolbar_mode: "wrap",

                // The default skin CSS is loaded manually as an import in
                // @Obsidian/Libs/tinymce.ts, so no need to specify one here.
                skin: false,

                // Content CSS is not needed since TinyMCE is loaded inline (instead of in an iframe)
                // and will inherit global Rock styles.
                content_css: false,

                // Hide the header menu bar and the footer status bar (which includes the TinyMCE attribution).
                menubar: false,
                statusbar: false,

                // Allow the editor to be resizable: true - vertical, false - none, 'both' - horizontal & vertical
                resize: "both",

                // Only include the plugins that are needed to keep TinyMCE leaner.
                plugins: "image link lists media searchreplace table",

                // Set the toolbar buttons.
                // They are displayed in the order in which they are defined
                // and grouped using pipe (|) characters.
                // FYI: Pasting from Word directly in the content area formats correctly,
                // so so need to create a rockpastefromword plugin at this point.
                // https://www.tiny.cloud/docs/tinymce/6/available-toolbar-buttons/
                toolbar: `${rockEditSourceCodePlugin.toolbar.editSourceCode} | bold italic strikethrough link forecolor backcolor | styles | numlist bullist | removeformat | ${rockParagraphPlugin.toolbar.paragraph} | ${rockMergeFieldPlugin.toolbar.mergeField} | image file | ${rockPasteAsPlainTextPlugin.toolbar.pasteAsPlainText} | undo redo`,

                // Define the options for the `styles` toolbar button.
                // This were chosen to match the previous HTML Editor control.
                // https://www.tiny.cloud/docs/tinymce/6/user-formatting-options/#style_formats
                style_formats: [
                    { title: "Normal", format: "p" },
                    // TODO There is a TinyMCE style that hides the left border for the <blockquote> format option.
                    { title: "Quote", block: "blockquote" },
                    { title: "Code", format: "pre" },
                    { title: "Heading 1", format: "h1" },
                    { title: "Heading 2", format: "h2" },
                    { title: "Heading 3", format: "h3" },
                    { title: "Heading 4", format: "h4" },
                    { title: "Heading 5", format: "h5" },
                    { title: "Heading 6", format: "h6" }
                ],


                // Define the options for the `forecolor` and `backcolor` toolbar buttons.
                // https://www.tiny.cloud/docs/tinymce/6/user-formatting-options/#text-color-options
                color_map: [
                    "#000000", "Black",
                    "#424242", "Tundora",
                    "#636363", "Dove Gray",
                    "#9C9C94", "Star Dust",
                    "#CEC6CE", "Pale Slate",
                    "#EFEFEF", "Gallery",
                    "#F7F7F7", "Alabaster",
                    "#FFFFFF", "White",

                    "#FF0000", "Red",
                    "#FF9C00", "Orange Peel",
                    "#FFFF00", "Yellow",
                    "#00FF00", "Green",
                    "#00FFFF", "Cyan",
                    "#0000FF", "Blue",
                    "#9C00FF", "Electric Violet",
                    "#FF00FF", "Magenta",

                    "#F7C6CE", "Azalea",
                    "#FFE7CE", "Karry",
                    "#FFEFC6", "Egg White",
                    "#D6EFD6", "Zanah",
                    "#CEDEE7", "Botticelli",
                    "#CEE7F7", "Tropical Blue",
                    "#D6D6E7", "Mischka",
                    "#E7D6DE", "Twilight",

                    "#E79C9C", "Tonys Pink",
                    "#FFC69C", "Peach Orange",
                    "#FFE79C", "Cream Brulee",
                    "#B5D6A5", "Sprout",
                    "#A5C6CE", "Casper",
                    "#9CC6EF", "Perano",
                    "#B5A5D6", "Cold Purple",
                    "#D6A5BD", "Careys Pink",

                    "#E76363", "Mandy",
                    "#F7AD6B", "Rajah",
                    "#FFD663", "Dandelion",
                    "#94BD7B", "Olivine",
                    "#73A5AD", "Gulf Stream",
                    "#6BADDE", "Viking",
                    "#8C7BC6", "Blue Marguerite",
                    "#C67BA5", "Puce",

                    "#CE0000", "Guardsman Red",
                    "#E79439", "Fire Bush",
                    "#EFC631", "Golden Dream",
                    "#6BA54A", "Chelsea Cucumber",
                    "#4A7B8C", "Smalt Blue",
                    "#3984C6", "Boston Blue",
                    "#634AA5", "Butterfly Bush",
                    "#A54A7B", "Cadillac",

                    "#9C0000", "Sangria",
                    "#B56308", "Mai Tai",
                    "#BD9400", "Buddha Gold",
                    "#397B21", "Forest Green",
                    "#104A5A", "Eden",
                    "#085294", "Venice Blue",
                    "#311873", "Meteorite",
                    "#731842", "Claret",

                    "#630000", "Rosewood",
                    "#7B3900", "Cinnamon",
                    "#846300", "Olive",
                    "#295218", "Parsley",
                    "#083139", "Tiber",
                    "#003163", "Midnight Blue",
                    "#21104A", "Valentino",
                    "#4A1031", "Loulou"
                ],
                color_default_background: "#FFFF00",
                color_default_foreground: "#000000",

                // Define the options for the `link` toolbar button.
                // https://www.tiny.cloud/docs/plugins/opensource/link/
                link_context_toolbar: true,
                link_assume_external_targets: "https",
                link_title: false,
                default_link_target: "_blank",
                target_list: [
                    { title: "New window", value: "_blank" },
                    { title: "Current window", value: "" },
                ],

                // The callback that is executed when the editor is initialized.
                setup: (editor): void => {
                    // Keep track of the editor instance.
                    tinyMceInstance.value = editor;

                    // Add Rock plugins.
                    rockEditSourceCodePlugin.init(editor);
                    rockPasteAsPlainTextPlugin.init(editor);
                    rockParagraphPlugin.init(editor);
                    rockMergeFieldPlugin.init(editor);

                    // TODO Add Image Browser plugin.
                    // TODO Add File Browser plugin.
                    // TODO Add Asset Manager plugin.

                    // Add shortcuts that were available with the previous editor library.
                    // Adding all valid shortcut combinations so we can overwrite shortcuts
                    // that may have been assigned by other plugins.
                    // https://www.tiny.cloud/docs/tinymce/6/shortcuts/
                    // https://www.tiny.cloud/docs/tinymce/6/keyboard-shortcuts/

                    // Insert list shortcuts.
                    // https://www.tiny.cloud/docs/tinymce/6/lists/#commands
                    editor.addShortcut("access+8,shift+alt+8,alt+shift+8", "Inserts an ordered list into the editor.", (): void => {
                        editor.execCommand("InsertOrderedList", false, {
                            "list-style-type": "decimal"
                        });
                    });
                    editor.addShortcut("access+9,shift+alt+9,alt+shift+9", "Inserts an unordered list into the editor.", (): void => {
                        editor.execCommand("InsertUnorderedList", false, {
                            "list-style-type": "disc"
                        });
                    });

                    // Set the initial value.
                    editor.on("init", () => {
                        // If the modelValue is not set,
                        // then initialize from the initial value.
                        if (!props.modelValue && props.initialValue) {
                            internalValue.value = props.initialValue;
                        }
                    });

                    // Emit model updates when the editor content changes.
                    // https://www.tiny.cloud/docs/tinymce/6/events/
                    editor.on("change redo undo", (_e: EditorEvent<Events.ChangeEvent>): void => {
                        const newValue = editor.getContent();
                        if (editorValue.value !== newValue) {
                            editorValue.value = newValue;
                            internalValue.value = newValue;
                        }
                    });
                }
            });
        }

        // Add vertical resizing.
        resizer.value?.addEventListener("mousedown", onResizeStart, { once: true });
    });

    // #endregion

    onUnmounted(() => {
        if (tinyMceInstance.value) {
            tinyMceInstance.value.destroy();
        }
    });
</script>