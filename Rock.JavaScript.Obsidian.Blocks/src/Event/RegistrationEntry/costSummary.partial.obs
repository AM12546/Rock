<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <Loading :isLoading="isLoading">
        <div class="fee-table">
            <div class="row hidden-xs fee-header">
                <div :class="{ 'col-sm-6': hasDiscount, 'col-sm-9': !hasDiscount }">
                    <strong>Description</strong>
                </div>
                <div class="col-sm-3 fee-value">
                    <strong>Amount</strong>
                </div>
                <div v-if="hasDiscount" class="col-sm-3 fee-value">
                    <strong>Discounted Amount</strong>
                </div>
            </div>
            <div v-for="lineItem in augmentedLineItems" class="row" :class="lineItem.isFee ? 'fee-row-fee' : 'fee-row-cost'">
                <div :class="{ 'col-sm-6 fee-caption': hasDiscount, 'col-sm-9 fee-caption': !hasDiscount }">
                    {{ lineItem.description }} {{ registrationEntryState.viewModel.isPaymentPlanConfigured ? "(Payment Plan)" : "" }}
                </div>
                <div class="col-sm-3 fee-value">
                    <span class="visible-xs-inline">Amount:</span>
                    {{ `${currencyInfo.symbol} ${lineItem.amountFormatted}` }}
                </div>
                <div v-if="hasDiscount" class="col-sm-3 fee-value">
                    <HelpBlock v-if="lineItem.discountHelp" :text="lineItem.discountHelp" />
                    <span class="visible-xs-inline">Discounted Amount:</span>
                    {{ `${currencyInfo.symbol} ${lineItem.discountedAmountFormatted}` }}
                </div>
            </div>
            <div class="row fee-row-total">
                <div :class="{ 'col-sm-6 fee-caption': hasDiscount, 'col-sm-9 fee-caption': !hasDiscount }">
                    Total
                </div>
                <div class="col-sm-3 fee-value">
                    <span class="visible-xs-inline">Amount:</span>
                    {{ totalFormatted }}
                </div>
                <div v-if="hasDiscount" class="col-sm-3 fee-value">
                    <span class="visible-xs-inline">Discounted Amount:</span>
                    {{ discountedTotalFormatted }}
                </div>
            </div>
        </div>
        <div class="row fee-totals">
            <div class="col-sm-offset-8 col-sm-4 fee-totals-options">
                <div class="form-group static-control">
                    <label class="control-label">Total Cost</label>
                    <div class="control-wrapper">
                        <div class="form-control-static">
                            {{ discountedTotalFormatted }}
                        </div>
                    </div>
                </div>

                <div v-if="amountPreviouslyPaid" class="form-group static-control">
                    <label class="control-label">Previously Paid</label>
                    <div class="control-wrapper">
                        <div class="form-control-static">
                            {{ amountPreviouslyPaidFormatted }}
                        </div>
                    </div>
                </div>

                <template v-if="registrationEntryState.viewModel.session?.activePaymentPlan">
                    <div class="form-group static-control">
                        <label class="control-label">Payment Plan</label>
                        <div class="control-wrapper">
                            <div class="form-control-static">
                                <div>
                                    {{ formatCurrency(registrationEntryState.viewModel.session.activePaymentPlan.amountPerPayment, registrationEntryState.viewModel.currencyInfo) }} x {{ registrationEntryState.viewModel.session.activePaymentPlan.remainingNumberOfPayments }} ({{ registrationEntryState.viewModel.session.activePaymentPlan.transactionFrequencyText }})
                                </div>
                                <RockButton btnType="link"
                                            btnSize="xs"
                                            :disabled="isDeletePaymentPlanModalShown"
                                            @click="isDeletePaymentPlanModalShown = true">Delete</RockButton>
                            </div>
                        </div>
                    </div>
                </template>

                <NotificationBox v-if="deletePaymentPlanErrorMessage" alertType="danger">{{ deletePaymentPlanErrorMessage }}</NotificationBox>

                <template v-if="showAmountDueToday && maxAmountCanBePaid && !isPaymentPlanConfigured">
                    <div class="form-group static-control">
                        <label class="control-label">Minimum Due Today</label>
                        <div class="control-wrapper">
                            <div class="form-control-static">
                                {{ amountDueTodayFormatted }}
                            </div>
                        </div>
                    </div>

                    <CurrencyBox label="Amount To Pay Today"
                                 :rules="amountToPayTodayRules"
                                 v-model="registrationEntryState.amountToPayToday"
                                 formGroupClasses="form-right"
                                 inputGroupClasses="input-width-md amount-to-pay" />

                    <div class="form-group static-control">
                        <label class="control-label">Amount Remaining After Payment</label>
                        <div class="control-wrapper">
                            <div class="form-control-static">
                                {{ amountRemainingFormatted }}
                            </div>
                        </div>
                    </div>

                    <div v-if="isPaymentPlanConfigurationSupported(paymentPlanArgs) && !isPaymentPlanConfigured && !registrationEntryState.viewModel.session?.activePaymentPlan" class="form-group">
                        <RockButton btnType="default" btnSize="xs" @click="onOpenConfigurePaymentPlanModal">Configure a Payment Plan</RockButton>
                    </div>
                </template>

                <div v-else class="form-group static-control">
                    <label class="control-label">Amount Due</label>
                    <div class="control-wrapper">
                        <div class="form-control-static">
                            {{ maxAmountCanBePaidFormatted }}
                        </div>
                    </div>
                </div>

                <div v-if="isPaymentPlanConfigured" class="payment-plan well">
                    <RockLabel class="primary-label">Payment Plan</RockLabel>
                    <StaticFormControl label="Amount Due Today" :modelValue="formatCurrency(registrationEntryState.amountToPayToday, registrationEntryState.viewModel.currencyInfo)" />
                    <StaticFormControl :label="`${registrationEntryState.paymentPlan?.transactionFrequencyText} Payment Amount`" :modelValue="`${formatCurrency(registrationEntryState.paymentPlan?.amountPerPayment ?? 0, registrationEntryState.viewModel.currencyInfo)} x ${registrationEntryState.paymentPlan?.numberOfPayments ?? 0}`" />
                    <RockButton v-if="isPaymentPlanConfigurationSupported(paymentPlanArgs)" btnType="default" btnSize="xs" @click="onOpenConfigurePaymentPlanModal">Change</RockButton>
                    <RockButton v-if="isPaymentPlanConfigurationSupported(paymentPlanArgs)" btnType="link" btnSize="xs" @click="onCancelPaymentPlanConfiguration">Cancel</RockButton>
                </div>
            </div>
        </div>
    </Loading>

    <ConfigurePaymentPlanModal v-if="isPaymentPlanConfigurationSupported(paymentPlanArgs) && wipPaymentPlanConfiguration"
                               v-model="isConfigurePaymentPlanModalShown"
                               v-model:paymentPlanConfiguration="wipPaymentPlanConfiguration"
                               :balanceDue="createCurrency(maxAmountCanBePaid, currencyOptions)"
                               :currencyOptions="currencyOptions"
                               :paymentDeadlineDate="paymentPlanArgs.paymentPlanDeadlineDate"
                               :paymentPlanFrequencies="paymentPlanArgs.paymentPlanFrequencies"
                               @configure="onConfigurePaymentPlan" />

    <Modal v-model="isDeletePaymentPlanModalShown"
           saveText="Delete"
           @save="onDeletePaymentPlan">
        <p>Are you sure you want to delete this payment plan?</p>
    </Modal>
</template>

<style scoped>
.payment-plan :deep(.control-label:not(.primary-label)) {
    font-weight: normal;
}
</style>

<script setup lang="ts">
    import { computed, ref, watch } from "vue";
    import { CurrencyFormatString, CurrencyOptions, createCurrency, createReadonlyCurrencyOptions } from "./currency.partial";
    import { GetPersistSessionArgs, CurrentRegistrationEntryState, use, RegistrationCostSummary, formatCurrency, PaymentPlanFrequency, getPaymentPlanFrequency, PaymentPlanConfiguration, getPaymentPlanConfiguration, noopPaymentPlanFrequency, ConfigurePaymentPlan } from "./utils.partial";
    import CurrencyBox from "@Obsidian/Controls/currencyBox.obs";
    import HelpBlock from "@Obsidian/Controls/helpBlock.obs";
    import Loading from "@Obsidian/Controls/loading.obs";
    import Modal from "@Obsidian/Controls/modal.obs";
    import NotificationBox from "@Obsidian/Controls/notificationBox.obs";
    import { useInvokeBlockAction } from "@Obsidian/Utility/block";
    import { ValidationRule } from "@Obsidian/ValidationRules";
    import { RegistrationEntryCostSummaryBag } from "@Obsidian/ViewModels/Blocks/Event/RegistrationEntry/registrationEntryCostSummaryBag";
    import StaticFormControl from "@Obsidian/Controls/staticFormControl.obs";
    import { CurrencyInfoBag } from "@Obsidian/ViewModels/Utility/currencyInfoBag";
    import RockButton from "@Obsidian/Controls/rockButton.obs";
    import ConfigurePaymentPlanModal from "./configurePaymentPlanModal.partial.obs";
    import RockLabel from "@Obsidian/Controls/rockLabel.obs";
    import { RockDateTime } from "@Obsidian/Utility/rockDateTime";
    import { DefinedValue } from "@Obsidian/SystemGuids/definedValue";
    import { Guid } from "@Obsidian/Types";
    import { areEqual } from "@Obsidian/Utility/guid";

    enum RegistrationCostSummaryType {
        Cost = 0,
        Fee = 1,
        Discount = 2,
        Total = 3
    }

    type AugmentedLineItem = RegistrationEntryCostSummaryBag & {
        isFee: boolean;
        discountHelp: string;
        discountedAmountFormatted: string;
        amountFormatted: string;
    };

    const getRegistrationEntryBlockArgs = use(GetPersistSessionArgs);
    const invokeBlockAction = useInvokeBlockAction();
    const registrationEntryState = use(CurrentRegistrationEntryState);
    const { readonlyRegistrationCostSummary, updateRegistrationCostSummary } = use(RegistrationCostSummary);
    const currencyOptions: CurrencyOptions = createReadonlyCurrencyOptions({
        precision: registrationEntryState.viewModel.currencyInfo?.decimalPlaces ?? undefined,
        symbol: registrationEntryState.viewModel.currencyInfo?.symbol ?? undefined,
    });
    const { wipPaymentPlanConfiguration, finalPaymentPlanConfiguration } = use(ConfigurePaymentPlan);

    // #region Values

    const isLoading = ref<boolean>(false);
    const lineItems = ref<RegistrationEntryCostSummaryBag[]>([]);
    const isConfigurePaymentPlanModalShown = ref<boolean>(false);
    const isPaymentPlanConfigured = ref<boolean>(!!registrationEntryState.paymentPlan?.numberOfPayments && !!registrationEntryState.paymentPlan?.amountPerPayment);
    const isDeletePaymentPlanModalShown = ref<boolean>(false);
    const deletePaymentPlanErrorMessage = ref<string>("");

    // #endregion

    // #region Computed Values

    type PaymentPlanArgs = {
        paymentPlanDeadlineDate: RockDateTime;
        paymentPlanFrequencies: PaymentPlanFrequency[];
    };

    const paymentPlanArgs = computed<Partial<PaymentPlanArgs>>(() => ({
        paymentPlanDeadlineDate: paymentPlanDeadlineDate.value ?? undefined,
        paymentPlanFrequencies: paymentPlanFrequencies.value,
    }));

    /** Gets whether or not the payment plan feature can be shown. */
    function isPaymentPlanConfigurationSupported(args: Partial<PaymentPlanArgs>): args is PaymentPlanArgs {
        if (!args.paymentPlanDeadlineDate) {
            return false;
        }

        if (!args.paymentPlanFrequencies?.length) {
            return false;
        }

        return true;
    }

    const paymentPlanDeadlineDate = computed<RockDateTime | null>(() => {
        if (!registrationEntryState.viewModel.paymentDeadlineDate) {
            return null;
        }
        else {
            return RockDateTime.parseISO(registrationEntryState.viewModel.paymentDeadlineDate);
        }
    });

    /** Gets the valid payment plan frequencies. */
    const paymentPlanFrequencies = computed<PaymentPlanFrequency[]>(() => {
        const desiredStartDate = RockDateTime.now().date;
        const deadlineDate = paymentPlanDeadlineDate.value;

        if (!deadlineDate) {
            // The payment plan deadline date is required to calculate
            // the max number of payments per payment plan frequency.
            // If there is no deadline date, then return an empty array.
            return [];
        }

        // When getting payment plan frequencies in this component,
        // use the total remaining balance without accounting for
        // amounts that MIGHT be paid now (like "Amount To Pay Today" or a NEW payment plan).
        // The Configure Payment Plan modal will further filter these frequencies
        // based on configured values in the modal.
        const remainingBalance = createCurrency(maxAmountCanBePaid.value, currencyOptions);

        const frequencies = (registrationEntryState.viewModel.paymentPlanFrequencies ?? [])
            .map(listItemBag => getPaymentPlanFrequency(listItemBag, desiredStartDate, deadlineDate, remainingBalance))
            // Only return frequencies that can make at least
            // two payments for the given payment plan start date.
            .filter(frequency => frequency.maxNumberOfPayments >= 2);

        // Sort the frequencies.
        const rank: Record<string, number> = {
            [DefinedValue.TransactionFrequencyWeekly]: 1,
            [DefinedValue.TransactionFrequencyBiweekly]: 2,
            [DefinedValue.TransactionFrequencyFirstAndFifteenth]: 3,
            [DefinedValue.TransactionFrequencyTwicemonthly]: 4,
            [DefinedValue.TransactionFrequencyMonthly]: 5,
            [DefinedValue.TransactionFrequencyQuarterly]: 6,
            [DefinedValue.TransactionFrequencyTwiceyearly]: 7,
            [DefinedValue.TransactionFrequencyOneTime]: 8,
        };

        frequencies.sort((a, b): number => {
            const aOrder = a.listItemBag.value ? rank[a.listItemBag.value] : -1;
            const bOrder = b.listItemBag.value ? rank[b.listItemBag.value] : -1;

            return aOrder < bOrder ? -1 : bOrder < aOrder ? 1 : 0;
        });

        return frequencies;
    });

    /** Gets whether or not the payment plan feature can be shown. */
    // const isPaymentPlanConfigurationSupported = computed<boolean>(() => {
    //     return !!paymentPlanDeadlineDate.value && paymentPlanFrequencies.value.length > 0;
    // });

    const currencyInfo = computed<CurrencyInfoBag>(() => {
        return registrationEntryState.viewModel.currencyInfo ?? {
            decimalPlaces: 2,
            symbol: "$"
        };
    });

    /** Line items with some extra info computed for table rendering */
    const augmentedLineItems = computed<AugmentedLineItem[]>(() => {
        return lineItems.value.map(li => ({
            ...li,
            isFee: li.type === RegistrationCostSummaryType.Fee,
            discountHelp: (hasDiscount.value && li.cost === li.discountedCost) ? "This item is not eligible for the discount." : "",
            // Ignore the currency symbol when formatting.
            // It will be prepended with a space in the template.
            amountFormatted: formatCurrency(li.cost, { symbol: "" }),
            discountedAmountFormatted: formatCurrency(li.discountedCost, { symbol: "" })
        } as AugmentedLineItem));
    });

    /** Should the discount column in the fee table be shown? */
    const hasDiscount = computed<boolean>(() => {
        return lineItems.value.some(li => li.discountedCost !== li.cost);
    });

    /** The total cost before discounts */
    const total = computed<number>(() => {
        let total = 0;
        lineItems.value.forEach(li => total += li.cost);
        return total;
    });

    /** The total before discounts as a formatted string */
    const totalFormatted = computed<string>(() => {
        return formatCurrency(total.value, registrationEntryState.viewModel.currencyInfo);
    });

    /** The total cost before discounts */
    const defaultPaymentAmount = computed<number>(() => {
        let total = 0;
        let hasDefault = false;

        lineItems.value.forEach(li => {
            if (li.defaultPaymentAmount) {
                hasDefault = true;
                total += li.defaultPaymentAmount;
            }
        });

        total = hasDefault ? total : maxAmountCanBePaid.value;

        if (total > maxAmountCanBePaid.value) {
            total = maxAmountCanBePaid.value;
        }

        if (total < amountDueToday.value) {
            total = amountDueToday.value;
        }

        if (total < 0) {
            total = 0;
        }

        return total;
    });

    /** The total cost after discounts */
    const discountedTotal = computed<number>(() => {
        let total = 0;
        lineItems.value.forEach(li => total += li.discountedCost);
        return total;
    });

    /** The total after discounts as a formatted string */
    const discountedTotalFormatted = computed<string>(() => {
        return formatCurrency(discountedTotal.value, registrationEntryState.viewModel.currencyInfo);
    });

    /** The min amount that must be paid today */
    const amountDueToday = computed<number>(() => {
        if (amountPreviouslyPaid.value) {
            return 0;
        }

        let total = 0;
        lineItems.value.forEach(li => total += (Math.min(li.minimumPaymentAmount, li.discountedCost)));
        return total;
    });

    /** The min amount that must be paid today as a formatted string */
    const amountDueTodayFormatted = computed<string>(() => {
        return formatCurrency(amountDueToday.value, registrationEntryState.viewModel.currencyInfo);
    });

    /** Should the amount that is due today be shown */
    const showAmountDueToday = computed<boolean>(() => {
        return amountDueToday.value !== discountedTotal.value;
    });

    /** The amount previously paid */
    const amountPreviouslyPaid = computed<number>(() => {
        return registrationEntryState.viewModel.session?.previouslyPaid || 0;
    });

    /** The amount previously paid formatted as a string */
    const amountPreviouslyPaidFormatted = computed<string>(() => {
        return formatCurrency(amountPreviouslyPaid.value, registrationEntryState.viewModel.currencyInfo);
    });

    /** The max amount that can be paid today */
    const maxAmountCanBePaid = computed<number>(() => {
        // The max amount is the discounted total less the previously paid amount and an existing payment plan's remaining amount.
        const plannedPaymentAmount = registrationEntryState.viewModel.session?.activePaymentPlan?.remainingPlannedAmount ?? 0;
        const balance = discountedTotal.value - amountPreviouslyPaid.value - plannedPaymentAmount;

        if (balance > 0) {
            return balance;
        }
        return 0;
    });

    /** The max amount that can be paid today as a formatted string */
    const maxAmountCanBePaidFormatted = computed<string>(() => {
        return formatCurrency(maxAmountCanBePaid.value, registrationEntryState.viewModel.currencyInfo);
    });

    /** The amount that would remain if the user paid the amount indicated in the currency box */
    const amountRemaining = computed<number>(() => {
        const actual = maxAmountCanBePaid.value - registrationEntryState.amountToPayToday;
        const bounded = actual < 0 ? 0 : actual > maxAmountCanBePaid.value ? maxAmountCanBePaid.value : actual;
        return bounded;
    });

    /** The amount that would remain if the user paid the amount indicated in the currency box as a formatted string */
    const amountRemainingFormatted = computed<string>(() => {
        return formatCurrency(amountRemaining.value, registrationEntryState.viewModel.currencyInfo);
    });

    /** The validation rules for the amount to pay today */
    const amountToPayTodayRules = computed<ValidationRule[]>(() => {
        const currencyOptions: CurrencyOptions = createReadonlyCurrencyOptions({
            precision: registrationEntryState.viewModel.currencyInfo?.decimalPlaces ?? undefined,
            symbol: registrationEntryState.viewModel.currencyInfo?.symbol ?? undefined,
        });
        const rules: ValidationRule[] = [];

        let min = createCurrency(amountDueToday.value, currencyOptions);
        const max = createCurrency(maxAmountCanBePaid.value, currencyOptions);

        if (min.isGreaterThan(max)) {
            min = max;
        }

        if (min.isGreaterThan(0)) {
            rules.push("required");
        }
        else {
            rules.push("notblank");
        }

        rules.push(`gte:${min.format(CurrencyFormatString.decimal)}`);
        rules.push(`lte:${max.format(CurrencyFormatString.decimal)}`);

        return rules;
    });

    // #endregion

    // #region Functions

    /** Retrieve the line item costs from the server */
    async function fetchCostData(): Promise<void> {
        isLoading.value = true;
        // lineItems.value = [];

        try {
            const response = await invokeBlockAction<RegistrationEntryCostSummaryBag[]>("CalculateCost", {
                args: getRegistrationEntryBlockArgs()
            });

            if (response.data) {
                lineItems.value = response.data;
            }
            else {
                lineItems.value = [];
            }
        }
        catch (e) {
            lineItems.value = [];
            throw e;
        }
        finally {
            isLoading.value = false;
        }

        // Update the shared registration cost data.
        updateRegistrationCostSummary({
            paidAmount: amountPreviouslyPaid.value,
            remainingAmount: amountRemaining.value,
            minimumRemainingAmount: amountDueToday.value
        });
    }

    // #endregion

    // #region Event Handlers

    /**
     * Event handler that shows the payment plan delete confirmation.
     */
    async function onShowPaymentPlanDeleteConfirmation(): Promise<void> {
        if (registrationEntryState.viewModel.session) {
            // Clear the existing payment plan.
            registrationEntryState.viewModel.session.activePaymentPlan = null;
        }
        // Just in case, also clear any new payment plan that has been configured.
        registrationEntryState.paymentPlan = null;

        // Refresh the cost data as the previous payment plan may have reduced it.
        await fetchCostData();
    }

    /**
     * Event handler that deletes the registration's payment plan.
     */
    async function onDeletePaymentPlan(): Promise<void> {
        isLoading.value = true;
        isDeletePaymentPlanModalShown.value = false;
        deletePaymentPlanErrorMessage.value = "";

        try {
            const activePaymentPlan = registrationEntryState.viewModel.session?.activePaymentPlan;

            if (!activePaymentPlan) {
                // This shouldn't happen as the delete button should only
                // be shown when there is an active payment plan to delete.
                await onShowPaymentPlanDeleteConfirmation();
            }
            else {
                const result = await invokeBlockAction("DeletePaymentPlan");

                if (result?.isSuccess) {
                    await onShowPaymentPlanDeleteConfirmation();
                }
                else {
                    deletePaymentPlanErrorMessage.value = result.errorMessage ?? "An unknown error occurred while attempting to delete the payment plan.";
                }
            }
        }
        finally {
            isLoading.value = false;
        }
    }

    /**
     * Event handler that opens the Configure Payment Plan modal.
     */
    function onOpenConfigurePaymentPlanModal(): void {
        if (finalPaymentPlanConfiguration.value) {
            // Use the final payment plan configuration for the modal.
            wipPaymentPlanConfiguration.value = finalPaymentPlanConfiguration.value;
        }
        else if (!wipPaymentPlanConfiguration.value) {
            // Initialize the payment plan configuration from registration data.
            const transactionFrequencyGuid: Guid | null = registrationEntryState.paymentPlan?.transactionFrequencyGuid ?? null;
            const desiredPaymentPlanFrequency =
                transactionFrequencyGuid
                    ? paymentPlanFrequencies.value.find(p => areEqual(p.listItemBag.value, transactionFrequencyGuid)) ?? noopPaymentPlanFrequency
                    : noopPaymentPlanFrequency;

            const today: RockDateTime = RockDateTime.now().date;

            wipPaymentPlanConfiguration.value = getPaymentPlanConfiguration({
                amountToPayToday: createCurrency(
                    registrationEntryState.paymentPlan
                        ? registrationEntryState.amountToPayToday
                        : readonlyRegistrationCostSummary.value.minimumRemainingAmount,
                    currencyOptions),
                balanceDue: createCurrency(maxAmountCanBePaid.value, currencyOptions),
                desiredAllowedPaymentPlanFrequencies: paymentPlanFrequencies.value,
                desiredNumberOfPayments: registrationEntryState.paymentPlan?.numberOfPayments ?? 0,
                desiredPaymentPlanFrequency,
                desiredStartDate: registrationEntryState.paymentPlan?.startDate
                    ? RockDateTime.parseISO(registrationEntryState.paymentPlan.startDate) ?? today
                    : today,
                endDate: paymentPlanDeadlineDate.value ?? RockDateTime.now().addYears(1).date,
                minAmountToPayToday: createCurrency(readonlyRegistrationCostSummary.value.minimumRemainingAmount, currencyOptions),
            });
        }

        isConfigurePaymentPlanModalShown.value = true;
    }

    /**
     * Event handler that cancels a newly configured payment plan.
     *
     * This does not modify an existing payment plan on the registration.
     */
    function onCancelPaymentPlanConfiguration(): void {
        wipPaymentPlanConfiguration.value = null;
        finalPaymentPlanConfiguration.value = null;
        registrationEntryState.amountToPayToday = defaultPaymentAmount.value;
        registrationEntryState.paymentPlan = null;
    }

    /**
     * Event handler that configures a payment plan be added to the registration once it is submitted.
     */
    function onConfigurePaymentPlan(paymentPlanConfig: PaymentPlanConfiguration): void {
        finalPaymentPlanConfiguration.value = paymentPlanConfig;
        wipPaymentPlanConfiguration.value = null;
        registrationEntryState.amountToPayToday = paymentPlanConfig.amountToPayTodayPlusAdjustment.number;
        registrationEntryState.paymentPlan = {
            transactionFrequencyGuid: paymentPlanConfig.paymentPlanFrequency.transactionFrequency.definedValueGuid,
            amountPerPayment: paymentPlanConfig.amountPerPayment.number,
            numberOfPayments: paymentPlanConfig.numberOfPayments,
            transactionFrequencyText: paymentPlanConfig.paymentPlanFrequency.listItemBag.text,
            startDate: paymentPlanConfig.startDate?.toISOString(),
        };
    }

    // #endregion

    // #region Watchers

    // Updates the isPaymentPlanConfigured whenever the registration's payment plan is updated.
    watch(
        [
            () => registrationEntryState.paymentPlan?.transactionFrequencyGuid,
            () => registrationEntryState.paymentPlan?.amountPerPayment,
            () => registrationEntryState.paymentPlan?.numberOfPayments
        ],
        () => {
            isPaymentPlanConfigured.value =
                !!registrationEntryState?.paymentPlan?.numberOfPayments
                && !!registrationEntryState.paymentPlan.amountPerPayment;
        });

    // Updates the amount to pay today whenever the default payment amount changes.
    watch(defaultPaymentAmount, () => {
        if (finalPaymentPlanConfiguration.value) {
            // A NEW payment plan is configured so update the final version using the updated default payment amount.
            const finalConfig = finalPaymentPlanConfiguration.value;
            finalPaymentPlanConfiguration.value = getPaymentPlanConfiguration({
                amountToPayToday: finalConfig.amountToPayToday,
                balanceDue: createCurrency(defaultPaymentAmount.value, currencyOptions),
                desiredAllowedPaymentPlanFrequencies: finalConfig.paymentPlanFrequencies,
                desiredNumberOfPayments: finalConfig.numberOfPayments,
                desiredPaymentPlanFrequency: finalConfig.paymentPlanFrequency,
                desiredStartDate: finalConfig.startDate ?? RockDateTime.now().date,
                endDate: finalConfig.endDate,
                minAmountToPayToday: finalConfig.minAmountToPayToday,
            });
            onConfigurePaymentPlan(finalPaymentPlanConfiguration.value);
        }
        else if (wipPaymentPlanConfiguration.value) {
            // A payment plan is being configured is configured so update the WIP version using the updated default payment amount.
            const wipConfig = wipPaymentPlanConfiguration.value;
            wipPaymentPlanConfiguration.value = getPaymentPlanConfiguration({
                amountToPayToday: wipConfig.amountToPayToday,
                balanceDue: createCurrency(defaultPaymentAmount.value, currencyOptions),
                desiredAllowedPaymentPlanFrequencies: wipConfig.paymentPlanFrequencies,
                desiredNumberOfPayments: wipConfig.numberOfPayments,
                desiredPaymentPlanFrequency: wipConfig.paymentPlanFrequency,
                desiredStartDate: wipConfig.startDate ?? RockDateTime.now().date,
                endDate: wipConfig.endDate,
                minAmountToPayToday: wipConfig.minAmountToPayToday
            });
        }
        else {
            // A payment plan has not and is not being configured, so update the amount to pay today with the updated default payment amount.
            registrationEntryState.amountToPayToday = defaultPaymentAmount.value;
        }
    }, {
        // Immediately update the amount to pay today from the default payment amount if there isn't a configured payment plan.
        // If there is one already, then it will be updated once it gets loaded.
        immediate: !finalPaymentPlanConfiguration.value,
    });

    watch(() => registrationEntryState.discountCode, async (): Promise<void> => {
        await fetchCostData();
    });

    // #endregion

    fetchCostData();
</script>