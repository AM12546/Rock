<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <RockFormField :modelValue="items" v-bind="fieldProps" name="x-field">
        <Grid :data="gridData" itemTerm="Item" keyField="key" liveUpdates light @addItem="onAddItem" @selectItem="console.log">
            <ReorderColumn @orderChanged="orderChanged" />
            <AttributeColumns :attributes="attributeList" />
            <DeleteColumn @click="onDelete" disableConfirmation />
        </Grid>



        <div>TODO: ADD FORM</div>
        <div>TODO: EDIT FORM</div>
    </RockFormField>

    <h6 class="text-semibold">GRID DATA</h6>
    <pre>{{ JSON.stringify(gridData, null, 4) }}</pre>
    <h6 class="text-semibold">PROPS.MODELVALUE</h6>
    <pre>{{ JSON.stringify($props.modelValue, null, 4) }}</pre>
</template>

<script setup lang="ts">
    import { PropType, computed, ref, watch } from "vue";
    import RockFormField from "@Obsidian/Controls/rockFormField.obs";
    import Grid, { AttributeColumns, DeleteColumn, ReorderColumn } from "@Obsidian/Controls/grid";
    import { PublicAttributeBag } from "@Obsidian/ViewModels/Utility/publicAttributeBag";
    import { GridDataBag } from "@Obsidian/ViewModels/Core/Grid/gridDataBag";
    import { standardRockFormFieldProps, useStandardRockFormFieldProps } from "@Obsidian/Utility/component";
    import { emptyGuid } from "@Obsidian/Utility/guid";
    import { deepEqual } from "@Obsidian/Utility/util";
    import { clone } from "@Obsidian/Utility/objectUtils";

    const props = defineProps({
        modelValue: {
            type: Array as PropType<Record<string, unknown>[]>, // TODO: Define type
            default: []
        },

        attributes: {
            type: Object as PropType<Record<string, PublicAttributeBag>>,
            required: true
        },

        minRows: {
            type: Number,
            default: 0
        },

        maxRows: {
            type: Number,
            default: Infinity
        },

        ...standardRockFormFieldProps
    });

    const emit = defineEmits<{
        (e: "update:modelValue", value: Record<string, unknown>[]): void
    }>();


    // Main V-Model Binding
    const items = ref(clone(props.modelValue));

    watch(() => props.modelValue, () => {
        if (!deepEqual(props.modelValue, items.value, false)) {
            items.value = clone(props.modelValue);
        }
    }, { deep: true });

    watch(items, () => {
        if (!deepEqual(props.modelValue, items.value, false)) {
            emit("update:modelValue", clone(items.value));
        }
    }, { deep: true });


    const fieldProps = useStandardRockFormFieldProps(props);

    // This increments every time a new item is added. It is used to ensure a unique key for new items
    // since they all have an empty guid.
    let itemsAdded = 0;





    const gridData = computed<GridDataBag>(
        () => {
            console.log("GET GRID DATA");
            return {
                rows: props.modelValue.map(item => ({
                    key: (item.guid as string) + "##" + (item.key ?? ""),
                    order: item.order,
                    ...(item.attributeValues as Record<string, string>)
                }))
            };
        }
    );

    const attributeList = computed(
        () => Object.values(props.attributes).map(attr => ({
            fieldTypeGuid: attr.fieldTypeGuid,
            name: attr.key,
            title: attr.name
        }))
    );

    function onAddItem(): void {
        console.log("TODO! SHOW POPUP");
        items.value.push({
            guid: emptyGuid,
            key: ++itemsAdded,
            order: items.value.length,
            attributeValues: {
                "ArticleImage": "",
                "ArticleTitle": "I'm a new item " + itemsAdded,
                "ArticleContent": "To be or not to be? That is the question. Or is it? Is that last sentence the question?",
                "ArticleLink": "https://www.joezimjs.com"
            }
        });
    }

    function onDelete(key: string): void {
        const [itemGuid, itemKey] = key.split("##");
        const index = items.value.findIndex(i => i.guid == itemGuid && i.key == (itemKey || undefined));
        if (index !== -1) {
            items.value.splice(index, 1);
        }
    }

    /**
     * When the order of the items in the matrix is changed via drag and drop, rearrange the items in the
     * array and update the `order` property to match the array order.
     */
    function orderChanged(movedItem: Record<string, unknown>, beforeItem: Record<string, unknown> | null): void {
        // console.debug("⬇️", movedItem.key, movedItem.ArticleTitle, beforeItem?.key, beforeItem?.ArticleTitle, ...items.value);
        const [movedItemGuid, movedItemKey] = (movedItem.key as string).split("##");
        const [beforeItemGuid, beforeItemKey] = beforeItem == null ? [null, null] : (beforeItem.key as string).split("##");
        // console.debug("⬇️", movedItemGuid, movedItemKey, beforeItemGuid, beforeItemKey);

        const movedIndex = items.value.findIndex(i => i.guid == movedItemGuid && i.key == (movedItemKey || undefined));

        if (movedIndex < 0) {
            return;
        }

        const [trueMovedItem] = items.value.splice(movedIndex, 1);

        const beforeItemIndex = items.value.findIndex(i => i.guid == beforeItemGuid && i.key == (beforeItemKey || undefined));

        if (beforeItem == null || beforeItemIndex < 0) {
            items.value.push(trueMovedItem);
        }
        else {
            items.value.splice(beforeItemIndex, 0, trueMovedItem);
        }

        items.value.forEach((item, index) => {
            item.order = index;
        });
        // console.debug("⬇️", ...items.value);
    }


</script>
