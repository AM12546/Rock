<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <NotificationBox v-if="blockActionErrorMessage" :alertType="AlertType.Warning">
        {{ blockActionErrorMessage }}
    </NotificationBox>

    <NotificationBox v-else-if="isNoGroupsNotificationVisible" :alertType="AlertType.Info">
        You are currently not in any scheduled groups.
    </NotificationBox>

    <template v-if="isContentVisible">
        <TabbedBar v-model="selectedGroupGuid"
                   class="schedule-toolbox-group-tabs"
                   :tabs="groupList"
                   :disabled="disabled || isLoadingSignUps" />

        <NotificationBox v-if="saveSignUpErrorMessage"
                         class="schedule-toolbox-signup-save-error-message"
                         :alertType="AlertType.Warning">
            {{ saveSignUpErrorMessage }}
        </NotificationBox>

        <div v-if="instructionsHtml" v-html="instructionsHtml" class="schedule-toolbox-signup-instructions"></div>

        <NotificationBox v-if="areImmediateNeedSignUpsVisible"
                         class="schedule-toolbox-signup-immediate-needs"
                         :alertType="AlertType.Info"
                         :heading="immediateNeedsTitle ?? ''">

            <div v-if="immediateNeedsIntroduction"
                 class="schedule-toolbox-immediate-needs-introduction">
                {{ immediateNeedsIntroduction }}
            </div>

            <SignUpOccurrenceDate v-for="[date, occurrences] in immediateNeedsOccurrencesByDate"
                                  :key="`${selectedGroupGuid}-${date}`"
                                  :title="getOccurrenceDateTitle(date)"
                                  :occurrences="occurrences"
                                  :disabled="disabled || isLoadingSignUps"
                                  @updatedSignUps="setSignUps($event)" />
        </NotificationBox>

        <div v-if="areFutureWeekSignupsVisible" class="schedule-toolbox-signup-future-weeks">
            <SignUpOccurrenceDate v-for="[date, occurrences] in futureWeekOccurrencesByDate"
                                  :key="`${selectedGroupGuid}-${date}`"
                                  :title="getOccurrenceDateTitle(date)"
                                  :occurrences="occurrences"
                                  :disabled="disabled || isLoadingSignUps"
                                  @updatedSignUps="setSignUps($event)" />
        </div>
    </template>
</template>

<style scoped>
.schedule-toolbox-signup-save-error-message,
.schedule-toolbox-signup-instructions,
.schedule-toolbox-signup-immediate-needs {
    margin-top: 20px;
}
</style>

<script setup lang="ts">
    import { computed, inject, PropType, provide, ref, watch } from "vue";
    import SignUpOccurrenceDate from "./signUpOccurrenceDate.partial.obs";
    import { SaveSignUpErrorMessage, SelectedGroup, SelectedPersonGuid } from "./types.partial";
    import NotificationBox from "@Obsidian/Controls/notificationBox.obs";
    import TabbedBar from "@Obsidian/Controls/tabbedBar.obs";
    import { AlertType } from "@Obsidian/Enums/Controls/alertType";
    import { useInvokeBlockAction } from "@Obsidian/Utility/block";
    import { useVModelPassthrough } from "@Obsidian/Utility/component";
    import { toOrdinalSuffix } from "@Obsidian/Utility/numberUtils";
    import { RockDateTime } from "@Obsidian/Utility/rockDateTime";
    import { GetSignUpsRequestBag } from "@Obsidian/ViewModels/Blocks/Group/Scheduling/GroupScheduleToolbox/getSignUpsRequestBag";
    import { GroupBag } from "@Obsidian/ViewModels/Blocks/Group/Scheduling/GroupScheduleToolbox/groupBag";
    import { SignUpOccurrenceBag } from "@Obsidian/ViewModels/Blocks/Group/Scheduling/GroupScheduleToolbox/signUpOccurrenceBag";
    import { SignUpsBag } from "@Obsidian/ViewModels/Blocks/Group/Scheduling/GroupScheduleToolbox/signUpsBag";
    import { ListItemBag } from "@Obsidian/ViewModels/Utility/listItemBag";

    const invokeBlockAction = useInvokeBlockAction();

    const props = defineProps({
        isLoadingSignUps: {
            type: Boolean as PropType<boolean>,
            required: true
        },

        immediateNeedsTitle: {
            type: String as PropType<string | null | undefined>,
            default: ""
        },

        immediateNeedsIntroduction: {
            type: String as PropType<string | null | undefined>,
            default: ""
        },

        disabled: {
            type: Boolean as PropType<boolean>,
            default: false
        }
    });

    const emit = defineEmits<{
        (e: "update:isLoadingSignUps"): void
    }>();

    // #region Values

    const selectedPersonGuid = inject(SelectedPersonGuid, ref(""));
    const selectedGroup = inject(SelectedGroup);

    const blockActionErrorMessage = ref("");

    const isLoadingSignUps = useVModelPassthrough(props, "isLoadingSignUps", emit);
    const hasCompletedInitialLoad = ref(false);

    const schedulableGroups = ref<GroupBag[]>([]);
    const instructionsHtml = ref("");
    const signUpOccurrences = ref<SignUpOccurrenceBag[]>([]);

    const saveSignUpErrorMessage = ref("");

    // #endregion Values

    // #region Computed Values

    const isNoGroupsNotificationVisible = computed((): boolean => {
        return !!(!isLoadingSignUps.value && (!schedulableGroups.value?.length || !selectedGroup?.value));
    });

    const groupList = computed((): ListItemBag[] => {
        return schedulableGroups.value
            .filter((group: GroupBag) => group?.guid && group?.name)
            .map((group: GroupBag) => ({
                text: `${group.name}${group.campusName ? ` (${group.campusName})` : ""}`,
                value: group.guid
            }));
    });

    const selectedGroupGuid = computed<string>({
        get() {
            return selectedGroup?.value?.guid ?? "";
        },
        set(newValue) {
            getSignUps(newValue);
        }
    });

    const isContentVisible = computed((): boolean => {
        return !isNoGroupsNotificationVisible.value && hasCompletedInitialLoad.value;
    });

    const immediateNeedsOccurrencesByDate = computed((): Map<number, SignUpOccurrenceBag[]> => {
        const immediateOccurrences = signUpOccurrences.value
            ?.filter((o: SignUpOccurrenceBag) => o?.occurrenceDateTime && o.isImmediateNeed)
            ?? [];

        return groupOccurrencesByDate(immediateOccurrences);
    });

    const areImmediateNeedSignUpsVisible = computed((): boolean => {
        return !!immediateNeedsOccurrencesByDate.value.size;
    });

    const futureWeekOccurrencesByDate = computed((): Map<number, SignUpOccurrenceBag[]> => {
        const nonImmediateOccurrences = signUpOccurrences.value
            ?.filter((o: SignUpOccurrenceBag) => o?.occurrenceDateTime && !o.isImmediateNeed)
            ?? [];

        return groupOccurrencesByDate(nonImmediateOccurrences);
    });

    const areFutureWeekSignupsVisible = computed((): boolean => {
        return !!futureWeekOccurrencesByDate.value.size;
    });

    // #endregion Computed Values

    // #region Functions

    /**
     * Gets the additional time sign-ups for the selected person and group.
     *
     * @param groupGuid The selected group unique identifier.
     */
    async function getSignUps(groupGuid: string): Promise<void> {
        if (isLoadingSignUps.value) {
            return;
        }

        isLoadingSignUps.value = true;
        blockActionErrorMessage.value = "";
        saveSignUpErrorMessage.value = "";

        const bag: GetSignUpsRequestBag = {
            selectedPersonGuid: selectedPersonGuid.value,
            selectedGroupGuid: groupGuid
        };

        const result = await invokeBlockAction<SignUpsBag>("GetSignUps", { bag });
        isLoadingSignUps.value = false;

        if (!result.isSuccess) {
            blockActionErrorMessage.value = result.errorMessage || "Unknown error while trying to get additional time sign-ups.";
            setSignUps(null);
        }

        setSignUps(result.data);

        hasCompletedInitialLoad.value = true;
    }

    /**
     * Sets the internal values using the provided sign-ups data.
     *
     * @param signUps The sign-ups data from which to set the internal values.
     */
    function setSignUps(signUps: SignUpsBag | null | undefined): void {
        if (selectedGroup) {
            selectedGroup.value = signUps?.selectedGroup;
        }

        schedulableGroups.value = signUps?.schedulableGroups ?? [];
        instructionsHtml.value = signUps?.instructionsHtml ?? "";
        signUpOccurrences.value = signUps?.occurrences ?? [];
    }

    /**
     * Groups the provided occurrences by date.
     *
     * @param occurrences The occurrences to be grouped.
     */
    function groupOccurrencesByDate(occurrences: SignUpOccurrenceBag[]): Map<number, SignUpOccurrenceBag[]> {
        const groupedOccurrences = new Map<number, SignUpOccurrenceBag[]>();

        occurrences.forEach((o: SignUpOccurrenceBag) => {
            const date = RockDateTime.parseISO(o.occurrenceDateTime ?? "")?.date.toMilliseconds() ?? 0;

            let dateOccurrences = groupedOccurrences.get(date);
            if (!dateOccurrences) {
                dateOccurrences = [];
                groupedOccurrences.set(date, dateOccurrences);
            }

            dateOccurrences.push(o);
        });

        return groupedOccurrences;
    }

    /**
     * Gets the occurrence date title.
     *
     * @param date The date for which to get the title.
     */
    function getOccurrenceDateTitle(dateMilliseconds: number): string {
        let title: string | null | undefined;
        const rockDateTime = RockDateTime.fromMilliseconds(dateMilliseconds);
        if (rockDateTime) {
            title = rockDateTime.toASPString("dddd, MMM d");

            if (title) {
                const dateParts = title.split(" ");
                if (dateParts.length === 3) {
                    const ordinalDate = toOrdinalSuffix(+dateParts[2]);
                    title = [
                        dateParts[0],
                        dateParts[1],
                        ordinalDate ?? dateParts[2]
                    ].join(" ");
                }
            }
        }

        return title || "No Date Provided";
    }

    // #endregion Functions

    // #region Watchers

    watch(selectedPersonGuid, () => {
        if (selectedPersonGuid.value) {
            hasCompletedInitialLoad.value = false;
            getSignUps(selectedGroupGuid.value);
        }
    });

    // #endregion Watchers

    provide(SaveSignUpErrorMessage, saveSignUpErrorMessage);

    getSignUps(selectedGroupGuid.value);
</script>
