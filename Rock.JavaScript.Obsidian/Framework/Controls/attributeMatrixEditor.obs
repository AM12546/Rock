<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <RockFormField :modelValue="items" v-bind="fieldProps" name="attribute-matrix-editor">
        <Grid v-show="mode == 'grid'" :data="gridData" itemTerm="Item" keyField="key" liveUpdates light @addItem="onAddItem" @selectItem="onSelectItem">
            <ReorderColumn @orderChanged="onOrderChanged" />
            <FieldColumn v-for="attr in attributeList" :key="attr.fieldTypeGuid ?? ''" :field="attr.field ?? ''" :name="attr.field ?? ''" :title="attr.title ?? ''" :attribute="attributes[attr.field ?? '']" />
            <DeleteColumn @click="onDelete" disableConfirmation />
        </Grid>

        <RockForm v-if="mode == 'add'" class="well" @submit="onSubmitAddItem" novalidate>
            <AttributeValuesContainer v-model="newValue" :attributes="attributes" isEditMode />
            <NotificationBox v-if="error == 'add'" alertType="danger" dismissible @dismiss="error = null" />
            <RockButton type="submit" btnSize="sm" btnType="primary" autoDisable :isLoading="isLoading">Add</RockButton>
            <RockButton btnType="link" @click="onCancelAddOrEditItem" autoDisable :isLoading="isLoading">Cancel</RockButton>
        </RockForm>

        <RockForm v-if="mode == 'edit'" class="well" @submit="onSubmitEditItem" novalidate>
            <AttributeValuesContainer v-model="editValue" :attributes="attributes" isEditMode />
            <NotificationBox v-if="error == 'add'" alertType="danger" dismissible @dismiss="error = null" />
            <RockButton type="submit" btnSize="sm" btnType="primary" autoDisable :isLoading="isLoading">Save</RockButton>
            <RockButton btnType="link" @click="onCancelAddOrEditItem" autoDisable :isLoading="isLoading">Cancel</RockButton>
        </RockForm>
    </RockFormField>
</template>

<script setup lang="ts">
    import { PropType, computed, ref, watch } from "vue";
    import RockFormField from "@Obsidian/Controls/rockFormField.obs";
    import RockForm from "@Obsidian/Controls/rockForm.obs";
    import RockButton from "@Obsidian/Controls/rockButton.obs";
    import AttributeValuesContainer from "@Obsidian/Controls/attributeValuesContainer.obs";
    import Grid, { AttributeColumns, DeleteColumn, FieldColumn, ReorderColumn, TextColumn } from "@Obsidian/Controls/grid";
    import NotificationBox from "./notificationBox.obs";
    import { PublicAttributeBag } from "@Obsidian/ViewModels/Utility/publicAttributeBag";
    import { GridDataBag } from "@Obsidian/ViewModels/Core/Grid/gridDataBag";
    import { standardRockFormFieldProps, useStandardRockFormFieldProps } from "@Obsidian/Utility/component";
    import { emptyGuid, newGuid } from "@Obsidian/Utility/guid";
    import { deepEqual } from "@Obsidian/Utility/util";
    import { clone } from "@Obsidian/Utility/objectUtils";
    import { AttributeMatrixEditorNormalizeEditValueOptionsBag } from "@Obsidian/ViewModels/Rest/Controls/attributeMatrixEditorNormalizeEditValueOptionsBag.d";
    import { AttributeMatrixEditorNormalizeEditValueResultsBag } from "@Obsidian/ViewModels/Rest/Controls/attributeMatrixEditorNormalizeEditValueResultsBag.d";
    import { AttributeMatrixEditorPublicItemBag } from "@Obsidian/ViewModels/Rest/Controls/attributeMatrixEditorPublicItemBag.d";
    import { useHttp } from "@Obsidian/Utility/http";

    const props = defineProps({
        modelValue: {
            type: Array as PropType<AttributeMatrixEditorPublicItemBag[]>, // TODO: Define type
            default: []
        },

        attributes: {
            type: Object as PropType<Record<string, PublicAttributeBag>>,
            required: true
        },

        defaultAttributeValues: {
            type: Object as PropType<Record<string, string>>,
            default: {}
        },

        minRows: {
            type: Number,
            default: 0
        },

        maxRows: {
            type: Number,
            default: Infinity
        },

        ...standardRockFormFieldProps
    });

    const emit = defineEmits<{
        (e: "update:modelValue", value: Record<string, unknown>[]): void
        (e: "newItem", value: Record<string, unknown>): void
    }>();


    // Main V-Model Binding
    const items = ref(clone(props.modelValue));

    watch(() => props.modelValue, () => {
        if (!deepEqual(props.modelValue, items.value, false)) {
            items.value = clone(props.modelValue);
        }
    }, { deep: true });

    watch(items, () => {
        if (!deepEqual(props.modelValue, items.value, false)) {
            emit("update:modelValue", clone(items.value));
        }
    }, { deep: true });


    const fieldProps = useStandardRockFormFieldProps(props);

    const http = useHttp();
    const mode = ref<"grid" | "edit" | "add">("grid");
    const newValue = ref({});
    const editValue = ref({});
    const editKey = ref("");
    const isLoading = ref(false);
    const error = ref<"add" | "edit" | null>(null);
    const keySeparator = "##";

    // This increments every time a new item is added. It is used to ensure a unique key for new items
    // since they all have an empty guid.
    let itemsAdded = 0;


    const gridData = computed<GridDataBag>(
        () => ({
            rows: props.modelValue.map(item => {
                const row = {
                    key: item.guid + keySeparator + (item.key ?? ""),
                    order: item.order,
                    ...(item.viewValues)
                };

                return row;
            })
        })
    );

    const attributeList = computed(
        () => Object.values(props.attributes).map(attr => ({
            fieldTypeGuid: attr.fieldTypeGuid,
            field: attr.key,
            title: attr.name
        }))
    );

    function onAddItem(): void {
        newValue.value = Object.keys(props.attributes).reduce((obj, key) => {
            obj[key] = props.defaultAttributeValues[key] ?? "";
            return obj;
        }, {});

        mode.value = "add";
    }

    async function onSubmitAddItem(): Promise<void> {
        error.value = null;

        const data = await normalizeEditValue(newValue.value);

        if (!data) {
            error.value = "add";
            return;
        }

        items.value.push({
            guid: emptyGuid,
            key: ++itemsAdded,
            order: items.value.length,
            ...data
        });

        newValue.value = {};
        mode.value = "grid";
    }

    function onCancelAddOrEditItem(): void {
        editKey.value = "";
        editValue.value = {};
        newValue.value = {};
        mode.value = "grid";
    }

    function onSelectItem(key: string): void {
        const [itemGuid, itemKey] = key.split(keySeparator);
        const item = items.value.find(i => i.guid == itemGuid && i.key == (itemKey || undefined));

        if (item != undefined) {
            editValue.value = clone(item.editValues ?? {});
            editKey.value = key;
            mode.value = "edit";
        }
    }

    async function onSubmitEditItem(): Promise<void> {
        error.value = null;

        const [itemGuid, itemKey] = editKey.value.split(keySeparator);
        const index = items.value.findIndex(i => i.guid == itemGuid && i.key == (itemKey || undefined));

        if (index < 0) {
            mode.value = "grid";
            return;
        }

        const data = await normalizeEditValue(editValue.value);

        if (!data) {
            error.value = "edit";
            return;
        }

        items.value[index].editValues = data.editValues;
        items.value[index].viewValues = data.viewValues;

        editKey.value = "";
        editValue.value = {};
        mode.value = "grid";
    }

    function onDelete(key: string): void {
        const [itemGuid, itemKey] = key.split(keySeparator);
        const index = items.value.findIndex(i => i.guid == itemGuid && i.key == (itemKey || undefined));
        if (index !== -1) {
            items.value.splice(index, 1);
        }
    }

    /**
     * When the order of the items in the matrix is changed via drag and drop, rearrange the items in the
     * array and update the `order` property to match the array order.
     */
    function onOrderChanged(movedItem: Record<string, unknown>, beforeItem: Record<string, unknown> | null): void {
        const [movedItemGuid, movedItemKey] = (movedItem.key as string).split(keySeparator);
        const [beforeItemGuid, beforeItemKey] = beforeItem == null ? [null, null] : (beforeItem.key as string).split(keySeparator);

        const movedIndex = items.value.findIndex(i => i.guid == movedItemGuid && i.key == (movedItemKey || undefined));

        if (movedIndex < 0) {
            return;
        }

        const [trueMovedItem] = items.value.splice(movedIndex, 1);

        const beforeItemIndex = items.value.findIndex(i => i.guid == beforeItemGuid && i.key == (beforeItemKey || undefined));

        if (beforeItem == null || beforeItemIndex < 0) {
            items.value.push(trueMovedItem);
        }
        else {
            items.value.splice(beforeItemIndex, 0, trueMovedItem);
        }

        items.value.forEach((item, index) => {
            item.order = index;
        });
    }

    async function normalizeEditValue(editValue: Record<string, string>): Promise<false | AttributeMatrixEditorNormalizeEditValueResultsBag> {
        isLoading.value = true;

        const options: AttributeMatrixEditorNormalizeEditValueOptionsBag = {
            attributes: props.attributes,
            attributeValues: editValue
        };
        const response = await http.post<AttributeMatrixEditorNormalizeEditValueResultsBag>("/api/v2/Controls/AttributeMatrixEditorNormalizeEditValue", undefined, options);

        isLoading.value = false;

        if (response.isSuccess && response.data) {
            return response.data;
        }
        else {
            console.error("Error adding item.", response.errorMessage);
            return false;
        }
    }


</script>
