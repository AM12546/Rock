<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <RockFormField :modelValue="items" v-bind="fieldProps" name="TODO-field">
        <Grid v-show="mode == 'grid'" :data="gridData" itemTerm="Item" keyField="key" liveUpdates light @addItem="onAddItem" @selectItem="onSelectItem">
            <ReorderColumn @orderChanged="orderChanged" />
            <FieldColumn v-for="attr in attributeList" :key="attr.fieldTypeGuid ?? ''" :field="attr.field ?? ''" :name="attr.field ?? ''" :title="attr.title ?? ''" :attribute="attributes[attr.field ?? '']" />
            <DeleteColumn @click="onDelete" disableConfirmation />
        </Grid>

        <RockForm v-if="mode == 'add'" class="well" @submit="onSubmitAddItem" novalidate>
            <AttributeValuesContainer v-model="newValue" :attributes="attributes" isEditMode />
            <RockButton type="submit" btnSize="sm" btnType="primary">Add</RockButton>
            <RockButton btnType="link" @click="onCancelAddOrEditItem">Cancel</RockButton>
        </RockForm>

        <RockForm v-if="mode == 'edit'" class="well" @submit="onSubmitEditItem" novalidate>
            <AttributeValuesContainer v-model="editValue" :attributes="attributes" isEditMode />
            <RockButton type="submit" btnSize="sm" btnType="primary">Save</RockButton>
            <RockButton btnType="link" @click="onCancelAddOrEditItem">Cancel</RockButton>
        </RockForm>
    </RockFormField>
</template>

<script setup lang="ts">
    import { PropType, computed, ref, watch } from "vue";
    import RockFormField from "@Obsidian/Controls/rockFormField.obs";
    import RockForm from "@Obsidian/Controls/rockForm.obs";
    import RockButton from "@Obsidian/Controls/rockButton.obs";
    import AttributeValuesContainer from "@Obsidian/Controls/attributeValuesContainer.obs";
    import Grid, { AttributeColumns, DeleteColumn, FieldColumn, ReorderColumn, TextColumn } from "@Obsidian/Controls/grid";
    import { PublicAttributeBag } from "@Obsidian/ViewModels/Utility/publicAttributeBag";
    import { GridDataBag } from "@Obsidian/ViewModels/Core/Grid/gridDataBag";
    import { standardRockFormFieldProps, useStandardRockFormFieldProps } from "@Obsidian/Utility/component";
    import { emptyGuid, newGuid } from "@Obsidian/Utility/guid";
    import { deepEqual } from "@Obsidian/Utility/util";
    import { clone } from "@Obsidian/Utility/objectUtils";
    import { provideSecurityGrant } from "@Obsidian/Utility/block";
    import { Props } from "ant-design-vue/lib/form/useForm";

    const props = defineProps({
        modelValue: {
            type: Array as PropType<Record<string, unknown>[]>, // TODO: Define type
            default: []
        },

        attributes: {
            type: Object as PropType<Record<string, PublicAttributeBag>>,
            required: true
        },

        defaultAttributeValues: {
            type: Object as PropType<Record<string, string>>,
            default: {}
        },

        minRows: {
            type: Number,
            default: 0
        },

        maxRows: {
            type: Number,
            default: Infinity
        },

        ...standardRockFormFieldProps
    });

    const emit = defineEmits<{
        (e: "update:modelValue", value: Record<string, unknown>[]): void
    }>();


    // Main V-Model Binding
    const items = ref(clone(props.modelValue));

    watch(() => props.modelValue, () => {
        if (!deepEqual(props.modelValue, items.value, false)) {
            items.value = clone(props.modelValue);
        }
    }, { deep: true });

    watch(items, () => {
        if (!deepEqual(props.modelValue, items.value, false)) {
            emit("update:modelValue", clone(items.value));
        }
    }, { deep: true });


    const fieldProps = useStandardRockFormFieldProps(props);

    const mode = ref<"grid" | "edit" | "add">("grid");
    const newValue = ref({});
    const editValue = ref({});
    const editKey = ref("");

    // This increments every time a new item is added. It is used to ensure a unique key for new items
    // since they all have an empty guid.
    let itemsAdded = 0;


    const gridData = computed<GridDataBag>(
        () => ({
            rows: props.modelValue.map(item => {
                const row = {
                    key: (item.guid as string) + "##" + (item.key ?? ""),
                    order: item.order,
                    ...(item.attributeValues as Record<string, string>)
                };

                return row;
            })
        })
    );

    const attributeList = computed(
        () => Object.values(props.attributes).map(attr => ({
            fieldTypeGuid: attr.fieldTypeGuid,
            field: attr.key,
            title: attr.name
        }))
    );

    function onAddItem(): void {
        newValue.value = Object.keys(props.attributes).reduce((obj, key) => {
            obj[key] = props.defaultAttributeValues[key] ?? "";
            return obj;
        }, {});

        mode.value = "add";
    }

    function onSubmitAddItem(): void {
        items.value.push({
            guid: emptyGuid,
            order: items.value.length,
            key: ++itemsAdded,
            attributeValues: clone(newValue.value)
        });

        mode.value = "grid";
    }

    function onCancelAddOrEditItem(): void {
        mode.value = "grid";
    }

    function onSelectItem(key: string): void {
        const [itemGuid, itemKey] = key.split("##");
        const item = items.value.find(i => i.guid == itemGuid && i.key == (itemKey || undefined));

        if (item != undefined) {
            editValue.value = clone(item.attributeValues as Record<string, unknown>);
            editKey.value = key;
            mode.value = "edit";
        }
    }

    function onSubmitEditItem(): void {
        const [itemGuid, itemKey] = editKey.value.split("##");
        const index = items.value.findIndex(i => i.guid == itemGuid && i.key == (itemKey || undefined));

        if (index >= 0) {
            items.value[index].attributeValues = editValue.value;
        }

        editKey.value = "";
        editValue.value = {};

        mode.value = "grid";
    }

    function onDelete(key: string): void {
        const [itemGuid, itemKey] = key.split("##");
        const index = items.value.findIndex(i => i.guid == itemGuid && i.key == (itemKey || undefined));
        if (index !== -1) {
            items.value.splice(index, 1);
        }
    }

    /**
     * When the order of the items in the matrix is changed via drag and drop, rearrange the items in the
     * array and update the `order` property to match the array order.
     */
    function orderChanged(movedItem: Record<string, unknown>, beforeItem: Record<string, unknown> | null): void {
        const [movedItemGuid, movedItemKey] = (movedItem.key as string).split("##");
        const [beforeItemGuid, beforeItemKey] = beforeItem == null ? [null, null] : (beforeItem.key as string).split("##");

        const movedIndex = items.value.findIndex(i => i.guid == movedItemGuid && i.key == (movedItemKey || undefined));

        if (movedIndex < 0) {
            return;
        }

        const [trueMovedItem] = items.value.splice(movedIndex, 1);

        const beforeItemIndex = items.value.findIndex(i => i.guid == beforeItemGuid && i.key == (beforeItemKey || undefined));

        if (beforeItem == null || beforeItemIndex < 0) {
            items.value.push(trueMovedItem);
        }
        else {
            items.value.splice(beforeItemIndex, 0, trueMovedItem);
        }

        items.value.forEach((item, index) => {
            item.order = index;
        });
    }


</script>
